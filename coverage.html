
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apperror: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">task_mission/apperror/errors.go (0.0%)</option>
				
				<option value="file1">task_mission/apps/handlers.go (0.0%)</option>
				
				<option value="file2">task_mission/apps/middlewares.go (0.0%)</option>
				
				<option value="file3">task_mission/apps/routers.go (0.0%)</option>
				
				<option value="file4">task_mission/apps/services.go (0.0%)</option>
				
				<option value="file5">task_mission/apps/usecases.go (0.0%)</option>
				
				<option value="file6">task_mission/cmd/task_mission/cmd/main.go (0.0%)</option>
				
				<option value="file7">task_mission/cmd/task_mission/drop/main.go (0.0%)</option>
				
				<option value="file8">task_mission/cmd/task_mission/migration/main.go (0.0%)</option>
				
				<option value="file9">task_mission/cmd/task_mission/seed/main.go (0.0%)</option>
				
				<option value="file10">task_mission/entities/dtos/requests/task_request.go (0.0%)</option>
				
				<option value="file11">task_mission/entities/dtos/responses/category_response.go (0.0%)</option>
				
				<option value="file12">task_mission/entities/dtos/responses/response.go (0.0%)</option>
				
				<option value="file13">task_mission/entities/dtos/responses/reward_response.go (0.0%)</option>
				
				<option value="file14">task_mission/entities/dtos/responses/task_response.go (0.0%)</option>
				
				<option value="file15">task_mission/entities/dtos/responses/user_task_response.go (0.0%)</option>
				
				<option value="file16">task_mission/enums/context_key.go (0.0%)</option>
				
				<option value="file17">task_mission/enums/router.go (0.0%)</option>
				
				<option value="file18">task_mission/enums/user_gender.go (0.0%)</option>
				
				<option value="file19">task_mission/handlers/category_handler.go (0.0%)</option>
				
				<option value="file20">task_mission/handlers/credit_handler.go (0.0%)</option>
				
				<option value="file21">task_mission/handlers/dev_handler.go (0.0%)</option>
				
				<option value="file22">task_mission/handlers/relation_handler.go (0.0%)</option>
				
				<option value="file23">task_mission/handlers/reward_handler.go (0.0%)</option>
				
				<option value="file24">task_mission/handlers/task_handler.go (0.0%)</option>
				
				<option value="file25">task_mission/handlers/user_handler.go (0.0%)</option>
				
				<option value="file26">task_mission/middlewares/authentication_middleware.go (0.0%)</option>
				
				<option value="file27">task_mission/middlewares/authorization_middleware.go (0.0%)</option>
				
				<option value="file28">task_mission/middlewares/cors_middleware.go (0.0%)</option>
				
				<option value="file29">task_mission/middlewares/logging_middleware.go (0.0%)</option>
				
				<option value="file30">task_mission/middlewares/timeout_middleware.go (0.0%)</option>
				
				<option value="file31">task_mission/mocks/usecasemocks/user_usecase.go (0.0%)</option>
				
				<option value="file32">task_mission/pkg/config/constructor.go (0.0%)</option>
				
				<option value="file33">task_mission/pkg/config/run.go (0.0%)</option>
				
				<option value="file34">task_mission/pkg/db/db.go (0.0%)</option>
				
				<option value="file35">task_mission/pkg/db/drop.go (0.0%)</option>
				
				<option value="file36">task_mission/pkg/db/migration.go (0.0%)</option>
				
				<option value="file37">task_mission/pkg/db/seed.go (0.0%)</option>
				
				<option value="file38">task_mission/pkg/email/mailtrap.go (0.0%)</option>
				
				<option value="file39">task_mission/pkg/email/sendgrid.go (0.0%)</option>
				
				<option value="file40">task_mission/pkg/firebases/firebase.go (0.0%)</option>
				
				<option value="file41">task_mission/pkg/grafana/otel.go (0.0%)</option>
				
				<option value="file42">task_mission/queries/query.go (0.0%)</option>
				
				<option value="file43">task_mission/repositories/category_repository.go (0.0%)</option>
				
				<option value="file44">task_mission/repositories/credit_repository.go (0.0%)</option>
				
				<option value="file45">task_mission/repositories/relation_repository.go (0.0%)</option>
				
				<option value="file46">task_mission/repositories/reward_category_repository.go (0.0%)</option>
				
				<option value="file47">task_mission/repositories/reward_repository.go (0.0%)</option>
				
				<option value="file48">task_mission/repositories/role_repository.go (0.0%)</option>
				
				<option value="file49">task_mission/repositories/task_repository.go (0.0%)</option>
				
				<option value="file50">task_mission/repositories/task_reward_repository.go (0.0%)</option>
				
				<option value="file51">task_mission/repositories/unit_of_work.go (0.0%)</option>
				
				<option value="file52">task_mission/repositories/user_credit_repository.go (0.0%)</option>
				
				<option value="file53">task_mission/repositories/user_profile_repository.go (0.0%)</option>
				
				<option value="file54">task_mission/repositories/user_repository.go (0.0%)</option>
				
				<option value="file55">task_mission/repositories/user_role_repository.go (0.0%)</option>
				
				<option value="file56">task_mission/repositories/user_task_repository.go (0.0%)</option>
				
				<option value="file57">task_mission/usecases/category_usecase.go (0.0%)</option>
				
				<option value="file58">task_mission/usecases/credit_usecase.go (0.0%)</option>
				
				<option value="file59">task_mission/usecases/relation_usecase.go (0.0%)</option>
				
				<option value="file60">task_mission/usecases/reward_usecase.go (0.0%)</option>
				
				<option value="file61">task_mission/usecases/task_usecase.go (0.0%)</option>
				
				<option value="file62">task_mission/usecases/user_usecase.go (0.0%)</option>
				
				<option value="file63">task_mission/utils/common.go (0.0%)</option>
				
				<option value="file64">task_mission/utils/query.go (0.0%)</option>
				
				<option value="file65">task_mission/utils/rest.go (0.0%)</option>
				
				<option value="file66">task_mission/utils/validate.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apperror

import (
        "log"
        "net/http"
)

type ErrType int

const (
        ErrBadRequest ErrType = iota + 1
        ErrNotFound
        ErrInternalServer
        ErrTimeout
        ErrUnauthorized
)

type CustomError struct {
        ErrType    ErrType
        LogMessage string
        err        error
}

func (cu *CustomError) Error() string <span class="cov0" title="0">{
        return cu.err.Error()
}</span>

func NewCustomError(errType ErrType, logMessage string, err error) *CustomError <span class="cov0" title="0">{
        log.Println(logMessage)
        return &amp;CustomError{
                ErrType:    errType,
                LogMessage: logMessage,
                err:        err,
        }
}</span>

func (cu *CustomError) ErrCode() int <span class="cov0" title="0">{
        switch cu.ErrType </span>{
        case ErrBadRequest:<span class="cov0" title="0">
                return http.StatusBadRequest</span>
        case ErrNotFound:<span class="cov0" title="0">
                return http.StatusNotFound</span>
        case ErrTimeout:<span class="cov0" title="0">
                return http.StatusGatewayTimeout</span>
        case ErrUnauthorized:<span class="cov0" title="0">
                return http.StatusUnauthorized</span>
        }
        <span class="cov0" title="0">return http.StatusInternalServerError</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package apps

import (
        handlers2 "task_mission/handlers"
        "task_mission/interfaces/handlers"
        "task_mission/pkg/db"
)

type Handlers struct {
        DevHandler      handlers.IDevHandler
        UserHandler     handlers.IUserHandler
        TaskHandler     handlers.ITaskHandler
        RelationHandler handlers.IRelationHandler
        RewardHandler   handlers.IRewardHandler
        CategoryHandler handlers.ICategoryHandler
        CreditHandler   handlers.ICreditHandler
}

func NewHandlers(repo *db.Repositories, service *Services) *Handlers <span class="cov0" title="0">{
        usecases := NewUseCases(repo)
        return &amp;Handlers{
                DevHandler:      handlers2.NewDevHandler(),
                UserHandler:     handlers2.NewUserHandler(usecases.UserUsecase),
                TaskHandler:     handlers2.NewTaskHandler(usecases.TaskUsecase),
                RelationHandler: handlers2.NewRelationHandler(usecases.RelationUsecase),
                RewardHandler:   handlers2.NewRewardHandler(usecases.RewardUsecase),
                CategoryHandler: handlers2.NewCategoryHandler(usecases.CategoryUsecase),
                CreditHandler:   handlers2.NewCreditHandler(usecases.CreditUsecase),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package apps

import (
        "github.com/gorilla/mux"
        "task_mission/middlewares"
)

func RegisterMiddleware(r *mux.Router) *mux.Router <span class="cov0" title="0">{
        r.Use(
                middlewares.LoggingMiddleware,
                middlewares.CorsMiddleware,
                middlewares.TimeoutMiddleware,
        )
        return r
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package apps

import (
        "github.com/gorilla/mux"
        "log"
        "net/http"
        "task_mission/enums"
        "task_mission/middlewares"
)

type EndpointRouter struct {
        path    string
        handler func(w http.ResponseWriter, r *http.Request)
        method  string
}

func RegisterEndpointRouter(path, method string, handler func(w http.ResponseWriter, r *http.Request)) *EndpointRouter <span class="cov0" title="0">{
        return &amp;EndpointRouter{path: path, handler: handler, method: method}
}</span>

func NewEndpointRouters(h *Handlers) map[enums.RouterPrefix][]EndpointRouter <span class="cov0" title="0">{
        endpointRouters := make(map[enums.RouterPrefix][]EndpointRouter)

        endpointRouters[enums.BasicRouter] = []EndpointRouter{
                *RegisterEndpointRouter("/hello", http.MethodGet, h.DevHandler.HelloDev),
                *RegisterEndpointRouter("/check-health", http.MethodGet, h.DevHandler.HealthCheck),
                *RegisterEndpointRouter("/email", http.MethodPost, h.DevHandler.SendTestEmail),
        }

        endpointRouters[enums.AuthRouter] = []EndpointRouter{
                *RegisterEndpointRouter("/register", http.MethodPost, h.UserHandler.RegisterHandler),
                *RegisterEndpointRouter("/login", http.MethodPost, h.UserHandler.LoginHandler),
        }

        endpointRouters[enums.TaskRouter] = []EndpointRouter{
                *RegisterEndpointRouter("", http.MethodPost, h.TaskHandler.CreateTaskHandler),
                *RegisterEndpointRouter("", http.MethodGet, h.TaskHandler.GetAllTasksHandler),
                *RegisterEndpointRouter("/{id}", http.MethodGet, h.TaskHandler.GetTaskDetailHandler),
        }

        endpointRouters[enums.RelationRouter] = []EndpointRouter{
                *RegisterEndpointRouter("", http.MethodPost, h.RelationHandler.AddFriend),
                *RegisterEndpointRouter("/followers", http.MethodGet, h.RelationHandler.GetAllFollowers),
                *RegisterEndpointRouter("/followings", http.MethodGet, h.RelationHandler.GetAllFollowings),
        }

        endpointRouters[enums.RewardRouter] = []EndpointRouter{
                *RegisterEndpointRouter("", http.MethodGet, h.RewardHandler.GetAllRewards),
                *RegisterEndpointRouter("/{id}", http.MethodGet, h.RewardHandler.GetReward),
                *RegisterEndpointRouter("/{id}", http.MethodPut, h.RewardHandler.UpdateReward),
                *RegisterEndpointRouter("/{id}", http.MethodDelete, h.RewardHandler.DeleteReward),
        }

        endpointRouters[enums.CategoryRouter] = []EndpointRouter{
                *RegisterEndpointRouter("", http.MethodGet, h.CategoryHandler.GetAllCategories),
                *RegisterEndpointRouter("/{id}", http.MethodGet, h.CategoryHandler.GetCategory),
                *RegisterEndpointRouter("", http.MethodPost, h.CategoryHandler.AddCategory),
        }

        endpointRouters[enums.CreditRouter] = []EndpointRouter{
                *RegisterEndpointRouter("", http.MethodPost, h.CreditHandler.GiveCredit),
                *RegisterEndpointRouter("", http.MethodGet, h.CreditHandler.SeeUserCredit),
        }

        return endpointRouters
}</span>

func (h *Handlers) InitRouter(r *mux.Router) <span class="cov0" title="0">{
        mapRouters := NewEndpointRouters(h)

        basicRouter := r.PathPrefix(enums.BasicRouter.ToString()).Subrouter()
        for _, router := range mapRouters[enums.BasicRouter] </span><span class="cov0" title="0">{
                basicRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.BasicRouter.ToString())
        }</span>

        <span class="cov0" title="0">authRouter := r.PathPrefix(enums.AuthRouter.ToString()).Subrouter()
        for _, router := range mapRouters[enums.AuthRouter] </span><span class="cov0" title="0">{
                authRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.AuthRouter.ToString())
        }</span>

        <span class="cov0" title="0">taskRouter := r.PathPrefix(enums.TaskRouter.ToString()).Subrouter()
        taskRouter.Use(middlewares.AuthenticationMiddleware)
        for _, router := range mapRouters[enums.TaskRouter] </span><span class="cov0" title="0">{
                taskRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.TaskRouter.ToString())
        }</span>

        <span class="cov0" title="0">relationRouter := r.PathPrefix(enums.RelationRouter.ToString()).Subrouter()
        relationRouter.Use(middlewares.AuthenticationMiddleware)
        for _, router := range mapRouters[enums.RelationRouter] </span><span class="cov0" title="0">{
                relationRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.RelationRouter.ToString())
        }</span>

        <span class="cov0" title="0">rewardRouter := r.PathPrefix(enums.RewardRouter.ToString()).Subrouter()
        rewardRouter.Use(middlewares.AuthenticationMiddleware)
        for _, router := range mapRouters[enums.RewardRouter] </span><span class="cov0" title="0">{
                rewardRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.RewardRouter.ToString())
        }</span>

        <span class="cov0" title="0">categoriesRouter := r.PathPrefix(enums.CategoryRouter.ToString()).Subrouter()
        categoriesRouter.Use(middlewares.AuthenticationMiddleware)
        for _, router := range mapRouters[enums.CategoryRouter] </span><span class="cov0" title="0">{
                categoriesRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.CategoryRouter.ToString())
        }</span>

        <span class="cov0" title="0">creditsRouter := r.PathPrefix(enums.CreditRouter.ToString()).Subrouter()
        creditsRouter.Use(middlewares.AuthenticationMiddleware)
        for _, router := range mapRouters[enums.CreditRouter] </span><span class="cov0" title="0">{
                creditsRouter.HandleFunc(router.path, router.handler).Methods(router.method)
                router.RouterLog(enums.CreditRouter.ToString())
        }</span>
}

func (router *EndpointRouter) RouterLog(prefix string) <span class="cov0" title="0">{
        //blue := color.New(color.FgBlue).SprintFunc()
        //red := color.New(color.FgRed).SprintFunc()
        //green := color.New(color.FgGreen).SprintFunc()

        log.Printf("%4s | %4s/ \n", router.method, prefix+router.path)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package apps

import (
        "context"
        "task_mission/pkg/firebases"
)

type Services struct {
        Firebase firebases.Firebase
}

func NewServices(ctx context.Context) (*Services, error) <span class="cov0" title="0">{
        firebaseConf, err := firebases.NewFirebaseConf(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Services{
                Firebase: firebaseConf,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package apps

import (
        "task_mission/interfaces/usecases"
        "task_mission/pkg/db"
        usecases2 "task_mission/usecases"
)

type Usecases struct {
        UserUsecase     usecases.IUserUsecase
        TaskUsecase     usecases.ITaskUsecase
        RelationUsecase usecases.IRelationUsecase
        RewardUsecase   usecases.IRewardUsecase
        CategoryUsecase usecases.ICategoryUsecase
        CreditUsecase   usecases.ICreditUseCase
}

func NewUseCases(repo *db.Repositories) *Usecases <span class="cov0" title="0">{
        return &amp;Usecases{
                UserUsecase:     usecases2.NewUserUsecase(repo.UnitOfWork, repo.UserRepository, repo.UserProfileRepository, repo.UserRoleRepository, repo.UserCreditRepository),
                TaskUsecase:     usecases2.NewTaskUsecase(repo.TaskRepository, repo.RewardRepository, repo.RewardCategoryRepository, repo.TaskRewardRepository, repo.UserRepository, repo.UserProfileRepository, repo.UserTaskRepository, repo.UnitOfWork),
                RelationUsecase: usecases2.NewRelationUsecase(repo.UnitOfWork, repo.RelationRepository, repo.UserRepository, repo.CreditRepository),
                RewardUsecase:   usecases2.NewRewardUsecase(repo.UnitOfWork, repo.RewardRepository, repo.TaskRepository, repo.UserRepository, repo.UserProfileRepository, repo.CategoryRepository, repo.RewardCategoryRepository, repo.TaskRewardRepository),
                CategoryUsecase: usecases2.NewCategoryUsecase(repo.CategoryRepository, repo.RewardRepository, repo.RewardCategoryRepository),
                CreditUsecase:   usecases2.NewCreditUsecase(repo.UserRepository, repo.CreditRepository, repo.UserCreditRepository),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "github.com/gorilla/mux"
        "log"
        "task_mission/apps"
        "task_mission/pkg/config"
        "task_mission/pkg/db"
)

func main() <span class="cov0" title="0">{
        configPath, err := config.ParseFlags()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">config, err := config.NewConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories, err := db.NewRepositories(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">services, err := apps.NewServices(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">handlers := apps.NewHandlers(repositories, services)

        r := mux.NewRouter()

        log.Println("UDAH KE RUN WA")

        r = apps.RegisterMiddleware(r)

        handlers.InitRouter(r)
        config.Run(r)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "log"
        "task_mission/pkg/config"
        "task_mission/pkg/db"
)

func main() <span class="cov0" title="0">{
        configPath, err := config.ParseFlags()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">config, err := config.NewConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories, err := db.NewRepositories(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories.DropTable(context.Background())</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "log"
        "task_mission/pkg/config"
        "task_mission/pkg/db"
)

func main() <span class="cov0" title="0">{
        configPath, err := config.ParseFlags()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">config, err := config.NewConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories, err := db.NewRepositories(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories.Migration(context.Background())</span>

}</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "log"
        "task_mission/pkg/config"
        "task_mission/pkg/db"
)

func main() <span class="cov0" title="0">{
        configPath, err := config.ParseFlags()
        ctx := context.Background()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">config, err := config.NewConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories, err := db.NewRepositories(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">repositories.SeedRole(ctx)
        repositories.SeedCategory(ctx)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package requests

import (
        "task_mission/entities/models"
        "task_mission/utils"
)

type RewardRequest struct {
        Name        string `json:"name"`
        Image       string `json:"image"`
        Description string `json:"description"`
}

type TaskRequest struct {
        Title       string `json:"title" validate:"required,min:3,max:36"`
        Description string `json:"description" validate:"required"`
        Image       string `json:"image"`
        ExpiredDate string `json:"expired_date"`
}

type CategoriesRequest struct {
        IDs []uint64 `json:"ids"`
}

type CreateTaskRequest struct {
        Task       TaskRequest       `json:"task" validate:"required"`
        Reward     RewardRequest     `json:"reward" validate:"required"`
        Categories CategoriesRequest `json:"categories" validate:"required"`
}

func (request *CreateTaskRequest) ConvertTask() *models.Task <span class="cov0" title="0">{
        taskRequest := request.Task
        expiredDate, err := utils.StringToDate(request.Task.ExpiredDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">task := &amp;models.Task{
                Title:       taskRequest.Title,
                Description: taskRequest.Description,
                Image:       taskRequest.Image,
                ExpiredDate: expiredDate,
        }
        return task</span>
}

func (request *CreateTaskRequest) ConvertReward() *models.Reward <span class="cov0" title="0">{
        rewardRequest := request.Reward
        reward := &amp;models.Reward{
                Name:        rewardRequest.Name,
                Image:       rewardRequest.Image,
                Description: rewardRequest.Description,
        }
        return reward
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package responses

import (
        "task_mission/entities/models"
        "time"
)

type (
        CategoryResponse struct {
                ID        uint64     `json:"id"`
                Category  string     `json:"category"`
                CreatedAt time.Time  `json:"created_at"`
                UpdatedAt time.Time  `json:"updated_at"`
                DeletedAt *time.Time `json:"deleted_at"`
        }

        CategoryDetailResponse struct {
                ID       uint64 `json:"id"`
                Category string `json:"category"`
                Rewards  []*struct {
                        ID          uint64 `json:"id"`
                        Name        string `json:"name"`
                        Image       string `json:"image"`
                        Description string `json:"description"`
                }
                CreatedAt time.Time  `json:"created_at"`
                UpdatedAt time.Time  `json:"updated_at"`
                DeletedAt *time.Time `json:"deleted_at"`
        }
)

func NewCategoryListResponse(category *models.Category) *CategoryResponse <span class="cov0" title="0">{
        return &amp;CategoryResponse{
                ID:        category.ID,
                Category:  category.Category,
                CreatedAt: category.CreatedAt.Local(),
                UpdatedAt: category.UpdatedAt.Local(),
                DeletedAt: category.DeletedAt,
        }
}</span>

func NewCategoryListResponses(categoryList []*models.Category) []*CategoryResponse <span class="cov0" title="0">{
        var result []*CategoryResponse
        for _, category := range categoryList </span><span class="cov0" title="0">{
                result = append(result, &amp;CategoryResponse{
                        ID:        category.ID,
                        Category:  category.Category,
                        CreatedAt: category.CreatedAt.Local(),
                        UpdatedAt: category.UpdatedAt.Local(),
                        DeletedAt: category.DeletedAt,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}

func NewCategoryDetailResponse(category *models.Category, rewards []*models.Reward) *CategoryDetailResponse <span class="cov0" title="0">{
        var rewardResponses []*struct {
                ID          uint64 `json:"id"`
                Name        string `json:"name"`
                Image       string `json:"image"`
                Description string `json:"description"`
        }

        for _, reward := range rewards </span><span class="cov0" title="0">{
                rewardResponses = append(rewardResponses, &amp;struct {
                        ID          uint64 `json:"id"`
                        Name        string `json:"name"`
                        Image       string `json:"image"`
                        Description string `json:"description"`
                }{ID: reward.ID, Name: reward.Name, Image: reward.Image, Description: reward.Description})
        }</span>

        <span class="cov0" title="0">return &amp;CategoryDetailResponse{
                ID:        category.ID,
                Category:  category.Category,
                Rewards:   rewardResponses,
                CreatedAt: category.CreatedAt.Local(),
                UpdatedAt: category.UpdatedAt.Local(),
                DeletedAt: category.DeletedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package responses

type Response struct {
        Message string `json:"message,omitempty"`
        Data    any    `json:"data,omitempty"`
        Error   error  `json:"error,omitempty"`
}

func NewResponse(message string, data any, err error) *Response <span class="cov0" title="0">{
        return &amp;Response{Message: message, Data: data, Error: err}
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package responses

import (
        "task_mission/entities/models"
        "task_mission/enums"
        "time"
)

type (
        RewardDetailResponse struct {
                ID          uint64 `json:"id"`
                Name        string `json:"name"`
                Image       string `json:"image"`
                Description string `json:"description"`
                User        struct {
                        ID       uint64 `json:"id"`
                        Name     string `json:"name"`
                        UserName string `json:"user_name"`
                        Image    string `json:"image"`
                } `json:"user"`
                Task struct {
                        ID          uint64           `json:"id"`
                        Title       string           `json:"title"`
                        Description string           `json:"description"`
                        Image       string           `json:"image"`
                        Status      enums.TaskStatus `json:"status"`
                        ExpiredDate time.Time        `json:"expired_date"`
                } `json:"task"`
                Categories []*struct {
                        ID       uint64 `json:"id"`
                        Category string `json:"category"`
                } `json:"categories"`
                CreatedAt time.Time  `json:"created_at"`
                UpdatedAt time.Time  `json:"updated_at"`
                DeletedAt *time.Time `json:"deleted_at"`
        }

        RewardListResponse struct {
                ID          uint64     `json:"id"`
                Name        string     `json:"name"`
                Image       string     `json:"image"`
                Description string     `json:"description"`
                CreatedAt   time.Time  `json:"created_at"`
                UpdatedAt   time.Time  `json:"updated_at"`
                DeletedAt   *time.Time `json:"deleted_at"`
        }
)

func NewRewardDetailResponse(reward *models.Reward, user *models.User, profile *models.UserProfile, task *models.Task, categories []*models.Category) *RewardDetailResponse <span class="cov0" title="0">{
        var categoryResponses []*struct {
                ID       uint64 `json:"id"`
                Category string `json:"category"`
        }
        for _, category := range categories </span><span class="cov0" title="0">{
                categoryResponses = append(categoryResponses, &amp;struct {
                        ID       uint64 `json:"id"`
                        Category string `json:"category"`
                }{
                        ID:       category.ID,
                        Category: category.Category,
                })
        }</span>
        <span class="cov0" title="0">return &amp;RewardDetailResponse{
                ID:          reward.ID,
                Name:        reward.Name,
                Image:       reward.Image,
                Description: reward.Description,
                User: struct {
                        ID       uint64 `json:"id"`
                        Name     string `json:"name"`
                        UserName string `json:"user_name"`
                        Image    string `json:"image"`
                }{ID: user.ID, Name: user.Name, UserName: user.UserName, Image: profile.Image},
                Task: struct {
                        ID          uint64           `json:"id"`
                        Title       string           `json:"title"`
                        Description string           `json:"description"`
                        Image       string           `json:"image"`
                        Status      enums.TaskStatus `json:"status"`
                        ExpiredDate time.Time        `json:"expired_date"`
                }{ID: task.ID, Title: task.Title, Description: task.Description, Image: task.Image, Status: task.Status, ExpiredDate: task.ExpiredDate.Local()},
                Categories: categoryResponses,
                CreatedAt:  reward.CreatedAt.Local(),
                UpdatedAt:  reward.UpdatedAt.Local(),
                DeletedAt:  reward.DeletedAt,
        }</span>
}

func NewRewardListResponse(reward *models.Reward) *RewardListResponse <span class="cov0" title="0">{
        return &amp;RewardListResponse{
                ID:          reward.ID,
                Name:        reward.Name,
                Image:       reward.Image,
                Description: reward.Description,
                CreatedAt:   reward.CreatedAt.Local(),
                UpdatedAt:   reward.UpdatedAt.Local(),
                DeletedAt:   reward.DeletedAt,
        }
}</span>

func NewRewardListResponses(rewards []*models.Reward) []*RewardListResponse <span class="cov0" title="0">{
        var result []*RewardListResponse
        for _, reward := range rewards </span><span class="cov0" title="0">{
                response := NewRewardListResponse(reward)
                result = append(result, response)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package responses

import (
        "task_mission/entities/models"
        "task_mission/enums"
        "time"
)

type (
        TaskResponse struct {
                ID        uint64     `json:"id"`
                TaskID    uint64     `json:"task_id"`
                UserID    uint64     `json:"user_id"`
                RewardID  uint64     `json:"reward_id"`
                CreatedAt time.Time  `json:"created_at"`
                UpdatedAt time.Time  `json:"updated_at"`
                DeletedAt *time.Time `json:"deleted_at"`
        }

        TaskListResponse struct {
                ID          uint64 `json:"id"`
                Title       string `json:"title"`
                Description string `json:"description"`
                ExpiryDate  string `json:"expiry_date"`
                Reward      struct {
                        ID   uint64 `json:"id"`
                        Name string `json:"name"`
                } `json:"reward"`
                User struct {
                        ID   uint64 `json:"id"`
                        Name string `json:"name"`
                } `json:"user"`
                Status    enums.TaskStatus `json:"status"`
                CreatedAt time.Time        `json:"created_at"`
                UpdatedAt time.Time        `json:"updated_at"`
                DeletedAt *time.Time       `json:"deleted_at"`
        }

        TaskDetailResponse struct {
                ID          uint64 `json:"id"`
                Title       string `json:"title"`
                Description string `json:"description"`
                ExpiryDate  string `json:"expiry_date"`
                Reward      struct {
                        ID          uint64 `json:"id"`
                        Name        string `json:"name"`
                        Image       string `json:"image"`
                        Description string `json:"description"`
                } `json:"reward"`
                User struct {
                        ID       uint64 `json:"id"`
                        Name     string `json:"name"`
                        UserName string `json:"user_name"`
                        Image    string `json:"image"`
                } `json:"user"`
                Status    enums.TaskStatus `json:"status"`
                CreatedAt time.Time        `json:"created_at"`
                UpdatedAt time.Time        `json:"updated_at"`
                DeletedAt *time.Time       `json:"deleted_at"`
        }
)

func NewTaskListResponse(task *models.Task, user *models.User, reward *models.Reward) *TaskListResponse <span class="cov0" title="0">{
        return &amp;TaskListResponse{
                ID:          task.ID,
                Title:       task.Title,
                Description: task.Description,
                ExpiryDate:  task.ExpiredDate.Format(time.RFC3339),
                Reward: struct {
                        ID   uint64 `json:"id"`
                        Name string `json:"name"`
                }{ID: reward.ID, Name: reward.Name},
                User: struct {
                        ID   uint64 `json:"id"`
                        Name string `json:"name"`
                }{ID: user.ID, Name: user.UserName},
                Status:    task.Status,
                CreatedAt: task.CreatedAt,
                UpdatedAt: task.UpdatedAt,
                DeletedAt: task.DeletedAt,
        }
}</span>

func NewTaskDetailResponse(task *models.Task, user *models.User, profile *models.UserProfile, reward *models.Reward) *TaskDetailResponse <span class="cov0" title="0">{
        return &amp;TaskDetailResponse{
                ID:          task.ID,
                Title:       task.Title,
                Description: task.Description,
                ExpiryDate:  task.ExpiredDate.Format(time.RFC3339),
                Reward: struct {
                        ID          uint64 `json:"id"`
                        Name        string `json:"name"`
                        Image       string `json:"image"`
                        Description string `json:"description"`
                }{ID: reward.ID, Name: reward.Name, Image: reward.Image, Description: reward.Description},
                User: struct {
                        ID       uint64 `json:"id"`
                        Name     string `json:"name"`
                        UserName string `json:"user_name"`
                        Image    string `json:"image"`
                }{ID: user.ID, Name: user.UserName, UserName: user.UserName, Image: profile.Image},
                Status:    task.Status,
                CreatedAt: task.CreatedAt.Local(),
                UpdatedAt: task.UpdatedAt.Local(),
                DeletedAt: task.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package responses

import (
        "task_mission/entities/models"
        "time"
)

type UserTaskResponse struct {
        ID        uint64     `json:"id"`
        TaskID    uint64     `json:"task_id"`
        UserID    uint64     `json:"user_id"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at"`
}

func NewUserTaskResponse(userTask *models.UserTask) *UserTaskResponse <span class="cov0" title="0">{
        return &amp;UserTaskResponse{
                ID:        userTask.ID,
                TaskID:    userTask.TaskID,
                UserID:    userTask.UserID,
                CreatedAt: userTask.CreatedAt.Local(),
                UpdatedAt: userTask.UpdatedAt.Local(),
                DeletedAt: userTask.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package enums

type ContextKey string

const (
        UserID    ContextKey = `user_id`
        RoleID               = `role_id`
        RequestID            = `request_id`
)

func (c ContextKey) ToString() string <span class="cov0" title="0">{
        return string(c)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package enums

type RouterPrefix string

func (r RouterPrefix) ToString() string <span class="cov0" title="0">{
        return string(r)
}</span>

const (
        BasicRouter    RouterPrefix = ""
        AuthRouter     RouterPrefix = `/auth`
        UserRouter                  = `/users`
        TaskRouter     RouterPrefix = `/tasks`
        RelationRouter RouterPrefix = `/relations`
        RewardRouter   RouterPrefix = `/rewards`
        CategoryRouter RouterPrefix = `/categories`
        CreditRouter   RouterPrefix = `/credits`
)
</pre>
		
		<pre class="file" id="file18" style="display: none">package enums

type UserGender string

const (
        Male   UserGender = `male`
        Female            = `female`
)

func (u UserGender) ToString() string <span class="cov0" title="0">{
        return string(u)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "context"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "net/http"
        "strconv"
        "task_mission/entities/dtos/requests"
        "task_mission/enums"
        "task_mission/interfaces/handlers"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type CategoryHandler struct {
        usecase usecases.ICategoryUsecase
}

func (c *CategoryHandler) AddCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                request = &amp;requests.CategoryRequest{}
                dataKey = `category`
        )
        result, customErr := c.usecase.CreateCategory(ctx, request)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to create category`, nil, nil, customErr)
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusCreated, `success create category`, &amp;dataKey, result, nil)</span>
}

func (c *CategoryHandler) GetAllCategories(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `categories`
        )
        result, customErr := c.usecase.GetAllCategories(ctx)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get categories`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get all categories`, &amp;dataKey, result, nil)</span>
}

func (c *CategoryHandler) GetCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `category`
                params  = mux.Vars(r)
        )
        id, err := strconv.Atoi(params["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, `failed to parse category id`, nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">categoryId := uint64(id)
        result, customErr := c.usecase.GetCategoryById(ctx, categoryId)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get category`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get category`, &amp;dataKey, result, nil)</span>
}

func NewCategoryHandler(usecase usecases.ICategoryUsecase) *CategoryHandler <span class="cov0" title="0">{
        return &amp;CategoryHandler{usecase: usecase}
}</span>

var _ handlers.ICategoryHandler = &amp;CategoryHandler{}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "context"
        "github.com/google/uuid"
        "net/http"
        "strconv"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/enums"
        "task_mission/interfaces/handlers"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type CreditHandler struct {
        creditUsecase usecases.ICreditUseCase
}

func (c *CreditHandler) GiveCredit(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                request = &amp;requests.CreditRequest{}
                dataKey = `credit`
        )
        if err := utils.BindJSON(r, request); err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, `invalid_json`, nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">result, customErr := c.creditUsecase.GiveCredit(ctx, request)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `internal_error`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusCreated, `success submit credit`, &amp;dataKey, result, nil)</span>
}

func (c *CreditHandler) SeeUserCredit(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                rID       = uuid.NewString()
                ctx       = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey   = `credits`
                result    any
                customErr *apperror.CustomError
        )
        userIdStr := r.URL.Query().Get(`userId`)
        if userIdStr == `` </span><span class="cov0" title="0">{
                result, customErr = c.creditUsecase.SeeAllCredits(ctx)
        }</span> else<span class="cov0" title="0"> {
                uId, err := strconv.Atoi(userIdStr)
                if err != nil </span><span class="cov0" title="0">{
                        utils.ResponseHandler(w, http.StatusBadRequest, `invalid_json`, nil, nil, err)
                        return
                }</span>
                <span class="cov0" title="0">userId := uint64(uId)
                result, customErr = c.creditUsecase.SeeUserCredit(ctx, userId)</span>
        }
        <span class="cov0" title="0">if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `internal_error`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get user credit`, &amp;dataKey, result, nil)</span>
}

var _ handlers.ICreditHandler = &amp;CreditHandler{}

func NewCreditHandler(creditUsecase usecases.ICreditUseCase) *CreditHandler <span class="cov0" title="0">{
        return &amp;CreditHandler{
                creditUsecase: creditUsecase,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "context"
        "github.com/hellofresh/health-go/v5"
        "net/http"
        "task_mission/interfaces/handlers"
        email2 "task_mission/pkg/email"
        "task_mission/utils"
        "time"
)

type DevHandler struct {
}

func (d *DevHandler) HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h, _ := health.New(health.WithComponent(health.Component{
                Name:    "myservice",
                Version: "v1.0",
        }), health.WithChecks(health.Config{
                Name:      "rabbitmq",
                Timeout:   time.Second * 5,
                SkipOnErr: true,
                Check: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        // rabbitmq health check implementation goes here
                        return nil
                }</span>}, health.Config{
                Name: "mongodb",
                Check: func(ctx context.Context) error <span class="cov0" title="0">{
                        // mongo_db health check implementation goes here
                        return nil
                }</span>,
        },
        ))
        //check := postgreSql.New(postgreSql.Config{
        //        DSN: "test:test@tcp(0.0.0.0:31726)/test?charset=utf8",
        //})
        <span class="cov0" title="0">h.Register(health.Config{
                Name:      "mysql",
                Timeout:   time.Second * 2,
                SkipOnErr: false,
        })</span>

}

func (d *DevHandler) HelloDev(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        utils.ResponseHandler(w, http.StatusOK, `hello world`, nil, nil, nil)
}</span>

func (d *DevHandler) SendTestEmail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        metadata := map[string]interface{}{
                "app_name":  "Bulletin Board",
                "curr_time": time.Now().Local(),
        }
        dataKey := `response`
        email := email2.NewMailtrap("randysteven12@gmail.com", "Test email", metadata)
        err := email.SendEmailTest()
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusInternalServerError, `failed`, nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success`, &amp;dataKey, nil, nil)

        utils.ContentType(w, "application/json")</span>
        //
        //metadata := map[string]interface{}{
        //        "app_name":  "Bulletin Board",
        //        "curr_time": time.Now().Local(),
        //}
        //
        //// Create a new email
        //email := email.NewEmail("randysteven12@gmail.com", "Test Email", metadata)
        //
        //// Send the test email and capture the response
        //resp, err := email.SendEmailTest()
        //if err != nil {
        //        // Log the error for debugging
        //        log.Printf("Error sending test email: %v", err)
        //        // Send an error response to the client
        //        utils.ResponseHandler(w, http.StatusInternalServerError, "failed", nil, nil, err)
        //        return
        //}
        //
        //// Log the successful response for debugging
        //log.Printf("Email sent successfully: %v", resp)
        //
        //// Send the response body and status code back to the client
        //dataKey := "response"
        //utils.ResponseHandler(w, resp.StatusCode, "success", &amp;dataKey, resp.Body, nil)
}

func NewDevHandler() *DevHandler <span class="cov0" title="0">{
        return &amp;DevHandler{}
}</span>

var _ handlers.IDevHandler = &amp;DevHandler{}
</pre>
		
		<pre class="file" id="file22" style="display: none">package handlers

import (
        "context"
        "github.com/google/uuid"
        "net/http"
        "task_mission/entities/dtos/requests"
        "task_mission/enums"
        "task_mission/interfaces/handlers"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type RelationHandler struct {
        usecase usecases.IRelationUsecase
}

func (rh *RelationHandler) GetAllFollowers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `followers`
        )
        result, customErr := rh.usecase.SeeAllFollowers(ctx)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get followers`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get all followers`, &amp;dataKey, result, nil)</span>
}

func (rh *RelationHandler) GetAllFollowings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `followers`
        )
        result, customErr := rh.usecase.SeeAllFollowings(ctx)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get followings`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get all followings`, &amp;dataKey, result, nil)</span>
}

func (rh *RelationHandler) AddFriend(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                request = &amp;requests.FriendRequest{}
                dataKey = `relation`
        )
        if err := utils.BindJSON(r, request); err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, `fail to parse request`, nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">result, customErr := rh.usecase.AddFriend(ctx, request)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get friend`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusCreated, `success to add friend`, &amp;dataKey, result, nil)</span>
}

func (rh *RelationHandler) GetAllFriends(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (rh *RelationHandler) FollowBack(w http.ResponseWriter, r *http.Request) {<span class="cov0" title="0">
}</span>

func (rh *RelationHandler) GetFriendWithUserID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

var _ handlers.IRelationHandler = &amp;RelationHandler{}

func NewRelationHandler(usecase usecases.IRelationUsecase) *RelationHandler <span class="cov0" title="0">{
        return &amp;RelationHandler{
                usecase: usecase,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "context"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "net/http"
        "strconv"
        "task_mission/enums"
        "task_mission/interfaces/handlers"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type RewardHandler struct {
        usecase usecases.IRewardUsecase
}

func (rh *RewardHandler) GetAllRewards(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `rewards`
        )
        result, customErr := rh.usecase.GetAllRewards(ctx)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get all rewards`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get all rewards`, &amp;dataKey, result, nil)</span>
}

func (rh *RewardHandler) GetReward(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `reward`
                params  = mux.Vars(r)
        )
        id, err := strconv.Atoi(params[`id`])
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, `invalid reward id`, nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">rewardId := uint64(id)
        result, customErr := rh.usecase.GetRewardByID(ctx, rewardId)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), `failed to get reward`, nil, nil, customErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success get reward`, &amp;dataKey, result, customErr)</span>
}

func (rh *RewardHandler) UpdateReward(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (rh *RewardHandler) DeleteReward(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func NewRewardHandler(usecase usecases.IRewardUsecase) *RewardHandler <span class="cov0" title="0">{
        return &amp;RewardHandler{
                usecase: usecase,
        }
}</span>

var _ handlers.IRewardHandler = &amp;RewardHandler{}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handlers

import (
        "context"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "net/http"
        "strconv"
        "task_mission/entities/dtos/requests"
        "task_mission/enums"
        "task_mission/interfaces/handlers"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type TaskHandler struct {
        taskUsecase usecases.ITaskUsecase
}

func (t *TaskHandler) TakeTaskHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                params  = mux.Vars(r)
                dataKey = `task`
        )
        idInt, err := strconv.Atoi(params["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, err.Error(), nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">id := uint64(idInt)
        res, controllerErr := t.taskUsecase.TakeTask(ctx, id)
        if controllerErr != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success update`, &amp;dataKey, res, nil)</span>
}

func (t *TaskHandler) CreateTaskHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                request = &amp;requests.CreateTaskRequest{}
                dataKey = `task_reward`
        )

        if err := utils.BindJSON(r, request); err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, err.Error(), nil, nil, err)
                return
        }</span>

        <span class="cov0" title="0">result, err := t.taskUsecase.CreateTask(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, err.ErrCode(), `failed to create task`, nil, nil, err)
                return
        }</span>

        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusCreated, `success to create task`, &amp;dataKey, result, nil)</span>
}

func (t *TaskHandler) GetAllTasksHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `tasks`
        )
        result, err := t.taskUsecase.GetAllTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, err.ErrCode(), `failed to get all tasks`, nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success to create task`, &amp;dataKey, result, nil)</span>
}

func (t *TaskHandler) GetTaskDetailHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID            = uuid.NewString()
                ctx            = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey        = `task`
                taskId  uint64 = 0
        )
        param := mux.Vars(r)
        taskIdInt, err := strconv.Atoi(param["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, err.Error(), nil, nil, err)
                return
        }</span>
        <span class="cov0" title="0">taskId = uint64(taskIdInt)
        result, controllerErr := t.taskUsecase.GetTaskDetail(ctx, taskId)
        if controllerErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, controllerErr.ErrCode(), `failed to get all tasks`, nil, nil, controllerErr)
                return
        }</span>
        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `success to get task`, &amp;dataKey, result, nil)</span>

}

var _ handlers.ITaskHandler = &amp;TaskHandler{}

func NewTaskHandler(taskUsecase usecases.ITaskUsecase) *TaskHandler <span class="cov0" title="0">{
        return &amp;TaskHandler{taskUsecase: taskUsecase}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "context"
        "github.com/google/uuid"
        "net/http"
        "sync"
        "task_mission/entities/dtos/requests"
        "task_mission/enums"
        "task_mission/interfaces/handlers"
        "task_mission/interfaces/usecases"
        email2 "task_mission/pkg/email"
        "task_mission/utils"
        "time"
)

type UserHandler struct {
        usecase usecases.IUserUsecase
}

func (u *UserHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                request = &amp;requests.UserRegisterRequest{}
                dataKey = `user`
                wg      sync.WaitGroup
        )

        if err := utils.BindJSON(r, &amp;request); err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, `failed to register user`, nil, nil, err)
                return
        }</span>

        <span class="cov0" title="0">result, err := u.usecase.RegisterUser(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusCreated, `failed to register user`, nil, nil, err)
                return
        }</span>

        <span class="cov0" title="0">metadata := map[string]interface{}{
                "name":        result.Name,
                "username":    result.UserName,
                "email":       request.Email,
                "joined_date": time.Now(),
        }

        email := email2.NewMailtrap(request.Email, "Register Email", metadata)

        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                err := email.SendEmailRegister()
                if err != nil </span><span class="cov0" title="0">{
                        utils.ResponseHandler(w, http.StatusInternalServerError, `failed to register email`, nil, nil, err)
                        return
                }</span>
                <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusCreated, `success register user`, &amp;dataKey, result, nil)</span>
        }()
        <span class="cov0" title="0">wg.Wait()</span>
}

func (u *UserHandler) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        utils.ContentType(w, "application/json")
        var (
                request = &amp;requests.UserLoginRequest{}
                rID     = uuid.NewString()
                ctx     = context.WithValue(r.Context(), enums.RequestID, rID)
                dataKey = `user`
        )

        if err := utils.BindJSON(r, request); err != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, http.StatusBadRequest, err.Error(), nil, nil, err)
                return
        }</span>

        <span class="cov0" title="0">token, customErr := u.usecase.LoginUser(ctx, request)
        if customErr != nil </span><span class="cov0" title="0">{
                utils.ResponseHandler(w, customErr.ErrCode(), customErr.Error(), nil, nil, customErr)
                return
        }</span>

        <span class="cov0" title="0">utils.ResponseHandler(w, http.StatusOK, `Success login`, &amp;dataKey, token, nil)</span>
}

func (u *UserHandler) UserProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *UserHandler) UserDetailHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *UserHandler) VerifyUser(w http.ResponseWriter, r *http.Request) {<span class="cov0" title="0">

}</span>

var _ handlers.IUserHandler = &amp;UserHandler{}

func NewUserHandler(usecase usecases.IUserUsecase) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                usecase: usecase,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package middlewares

import (
        "context"
        "github.com/golang-jwt/jwt/v5"
        "net/http"
        "task_mission/enums"
        "task_mission/pkg/securities"
        "task_mission/utils"
)

func AuthenticationMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                utils.ContentType(w, "application/json")
                auth := r.Header.Get("Authorization")
                if len(auth) == 0 || auth == "" </span><span class="cov0" title="0">{
                        utils.ResponseHandler(w, http.StatusUnauthorized, `Invalid get token from auth`, nil, nil, nil)
                        return
                }</span>
                <span class="cov0" title="0">tokenStr := auth[len("Bearer "):]
                if tokenStr == "" </span><span class="cov0" title="0">{
                        utils.ResponseHandler(w, http.StatusUnauthorized, `Invalid token failed to split from bearer`, nil, nil, nil)
                        return
                }</span>
                <span class="cov0" title="0">claims := &amp;securities.JWTClaim{}
                token, err := jwt.ParseWithClaims(tokenStr, claims, func(j *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return securities.JWT_KEY, nil
                }</span>)
                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        utils.ResponseHandler(w, http.StatusUnauthorized, `Invalid token`, nil, nil, err)
                        return
                }</span>
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), enums.UserID, claims.UserID)
                ctx2 := context.WithValue(ctx, enums.RoleID, claims.RoleID)
                r = r.WithContext(ctx2)
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package middlewares

import (
        "net/http"
)

func AuthorizationMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span>{<span class="cov0" title="0">
                //roleMap := make(map[string][]string)
                //roleMap[enums.UserRouter]
                //utils.ContentType(w, "application/json")
                //auth := r.Header.Get("Authorization")
                //if len(auth) == 0 || auth == "" {
                //        utils.ResponseHandler(w, http.StatusUnauthorized, `Invalid get token from auth`, nil, nil, nil)
                //        return
                //}
                //tokenStr := auth[len("Bearer "):]
                //if tokenStr == "" {
                //        utils.ResponseHandler(w, http.StatusUnauthorized, `Invalid token failed to split from bearer`, nil, nil, nil)
                //        return
                //}
                //claims := &amp;securities.JWTClaim{}
                //token, err := jwt.ParseWithClaims(tokenStr, claims, func(j *jwt.Token) (interface{}, error) {
                //        return securities.JWT_KEY, nil
                //})
                //if err != nil || !token.Valid {
                //        utils.ResponseHandler(w, http.StatusUnauthorized, `Invalid token`, nil, nil, err)
                //        return
                //}
                //ctx := context.WithValue(r.Context(), enums.UserID, claims.UserID)
                //ctx2 := context.WithValue(ctx, enums.RoleID, claims.RoleID)
                //r = r.WithContext(ctx2)
                //next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package middlewares

import "net/http"

func CorsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Credentials", "true")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                w.Header().Set("Access-Control-Request-Method", "POST, OPTIONS, GET, PUT, DELETE")
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package middlewares

import (
        "bytes"
        "encoding/json"
        "io/ioutil"
        "log"
        "net/http"
        "time"
)

func LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                log.Println("Entering logging middleware")

                requestTime := time.Now()

                body, err := ioutil.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to read request body: %v\n", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">r.Body = ioutil.NopCloser(bytes.NewBuffer(body))

                next.ServeHTTP(w, r)

                var requestBody interface{}
                if err := json.Unmarshal(body, &amp;requestBody); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to unmarshal request body: %v\n", err)
                        return
                }</span>
                <span class="cov0" title="0">log.Printf("%s %s %s %s\n", requestTime.Format("2006-01-02 15:04:05"), r.Method, r.URL.Path, requestBody)</span>
        })
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package middlewares

import (
        "context"
        "net/http"
        "time"
)

func TimeoutMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Create a new context with a timeout
                ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
                defer cancel()

                // Use the new context in the request
                r = r.WithContext(ctx)

                // Use a done channel to signal when the request handling is complete
                done := make(chan struct{})

                // Handle the request in a separate goroutine
                go func() </span><span class="cov0" title="0">{
                        defer close(done)
                        next.ServeHTTP(w, r)
                }</span>()

                // Wait for either the request handling to complete or the timeout to expire
                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        // Request handling completed within the timeout
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Timeout occurred before request handling completed
                        if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                http.Error(w, "Request timed out", http.StatusRequestTimeout)
                                return
                        }</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery v2.43.1. DO NOT EDIT.

package usecasemocks

import (
        context "context"
        apperror "task_mission/apperror"

        mock "github.com/stretchr/testify/mock"

        models "task_mission/entities/models"

        requests "task_mission/entities/dtos/requests"

        responses "task_mission/entities/dtos/responses"
)

// IUserUsecase is an autogenerated mock type for the IUserUsecase type
type IUserUsecase struct {
        mock.Mock
}

// LoginUser provides a mock function with given fields: ctx, login
func (_m *IUserUsecase) LoginUser(ctx context.Context, login *requests.UserLoginRequest) (*responses.UserLoginResponse, *apperror.CustomError) <span class="cov0" title="0">{
        ret := _m.Called(ctx, login)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LoginUser")</span>
        }

        <span class="cov0" title="0">var r0 *responses.UserLoginResponse
        var r1 *apperror.CustomError
        if rf, ok := ret.Get(0).(func(context.Context, *requests.UserLoginRequest) (*responses.UserLoginResponse, *apperror.CustomError)); ok </span><span class="cov0" title="0">{
                return rf(ctx, login)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *requests.UserLoginRequest) *responses.UserLoginResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, login)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*responses.UserLoginResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *requests.UserLoginRequest) *apperror.CustomError); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, login)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).(*apperror.CustomError)
                }</span>
        }

        <span class="cov0" title="0">return r0, r1</span>
}

// RegisterUser provides a mock function with given fields: ctx, register
func (_m *IUserUsecase) RegisterUser(ctx context.Context, register *requests.UserRegisterRequest) (*models.User, *apperror.CustomError) <span class="cov0" title="0">{
        ret := _m.Called(ctx, register)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RegisterUser")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 *apperror.CustomError
        if rf, ok := ret.Get(0).(func(context.Context, *requests.UserRegisterRequest) (*models.User, *apperror.CustomError)); ok </span><span class="cov0" title="0">{
                return rf(ctx, register)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *requests.UserRegisterRequest) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, register)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *requests.UserRegisterRequest) *apperror.CustomError); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, register)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).(*apperror.CustomError)
                }</span>
        }

        <span class="cov0" title="0">return r0, r1</span>
}

// VerifyUser provides a mock function with given fields: ctx, id
func (_m *IUserUsecase) VerifyUser(ctx context.Context, id uint64) (*models.User, *apperror.CustomError) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for VerifyUser")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 *apperror.CustomError
        if rf, ok := ret.Get(0).(func(context.Context, uint64) (*models.User, *apperror.CustomError)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, uint64) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, uint64) *apperror.CustomError); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).(*apperror.CustomError)
                }</span>
        }

        <span class="cov0" title="0">return r0, r1</span>
}

// NewIUserUsecase creates a new instance of IUserUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIUserUsecase(t interface {
        mock.TestingT
        Cleanup(func())
}) *IUserUsecase <span class="cov0" title="0">{
        mock := &amp;IUserUsecase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package config

import (
        "gopkg.in/yaml.v2"
        "os"
)

func NewConfig(configPath string) (*Config, error) <span class="cov0" title="0">{
        config := &amp;Config{}
        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        d := yaml.NewDecoder(file)
        if err := d.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "context"
        "flag"
        "fmt"
        "github.com/gorilla/mux"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
)

func ParseFlags() (string, error) <span class="cov0" title="0">{
        var configPath string
        flag.StringVar(&amp;configPath, "config", "./config.yml", "path to config file")
        flag.Parse()
        if err := ValidateConfigPath(configPath); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return configPath, nil</span>
}

func ValidateConfigPath(path string) error <span class="cov0" title="0">{
        s, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file format")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Config) Run(r *mux.Router) <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        srv := &amp;http.Server{
                Addr:         c.Server.Host + ":" + c.Server.Port,
                Handler:      r,
                ReadTimeout:  c.Server.Timeout.Read * time.Second,
                WriteTimeout: c.Server.Timeout.Write * time.Second,
                IdleTimeout:  c.Server.Timeout.Idle * time.Second,
        }
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("listen: %s\n", err)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()

        stop()

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server forced to shutdown: ", err)
        }</span>

        <span class="cov0" title="0">log.Println("Server exiting")</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package db

import (
        "database/sql"
        "fmt"
        _ "github.com/jackc/pgx/v5"
        _ "github.com/lib/pq"
        "log"
        "task_mission/interfaces/repositories"
        "task_mission/pkg/config"
        repositories2 "task_mission/repositories"
        "time"
)

type Repositories struct {
        UserRepository           repositories.IUserRepository
        RoleRepository           repositories.IRoleRepository
        CategoryRepository       repositories.ICategoryRepository
        UserProfileRepository    repositories.IUserProfileRepository
        UserRoleRepository       repositories.IUserRoleRepository
        TaskRepository           repositories.ITaskRepository
        RewardRepository         repositories.IRewardRepository
        TaskRewardRepository     repositories.ITaskRewardRepository
        RewardCategoryRepository repositories.IRewardCategoryRepository
        UserCreditRepository     repositories.IUserCreditRepository
        UserTaskRepository       repositories.IUserTaskRepository
        RelationRepository       repositories.IRelationRepository
        CreditRepository         repositories.ICreditRepository
        UnitOfWork               repositories.UnitOfWork
        db                       *sql.DB
}

func NewRepositories(config *config.Config) (*Repositories, error) <span class="cov0" title="0">{
        conn := fmt.Sprintf("postgresql://%s:%s@%s/%s?sslmode=require",
                config.Postgres.DbUser,
                config.Postgres.DbPass,
                config.Postgres.Host,
                config.Postgres.DbName,
        )
        log.Println(conn)
        db, err := sql.Open("postgres", conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxIdleConns(10)
        db.SetMaxOpenConns(8)
        db.SetConnMaxLifetime(10 * time.Minute)
        db.SetConnMaxIdleTime(8 * time.Minute)
        err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Repositories{
                UnitOfWork:               repositories2.NewUnitOfWork(db),
                UserRepository:           repositories2.NewUserRepository(db),
                UserProfileRepository:    repositories2.NewUserProfileRepository(db),
                RoleRepository:           repositories2.NewRoleRepository(db),
                CategoryRepository:       repositories2.NewCategoryRepository(db),
                TaskRepository:           repositories2.NewTaskRepository(db),
                RewardRepository:         repositories2.NewRewardRepository(db),
                RewardCategoryRepository: repositories2.NewRewardCategoryRepository(db),
                TaskRewardRepository:     repositories2.NewTaskRewardRepository(db),
                UserCreditRepository:     repositories2.NewUserCreditRepository(db),
                UserRoleRepository:       repositories2.NewUserRoleRepository(db),
                UserTaskRepository:       repositories2.NewUserTaskRepository(db),
                RelationRepository:       repositories2.NewRelationRepository(db),
                CreditRepository:         repositories2.NewCreditRepository(db),
                db:                       db,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package db

import (
        "context"
        "log"
        "task_mission/queries"
)

func initDropTables() []queries.DropTable <span class="cov0" title="0">{
        return []queries.DropTable{
                queries.DropUserTask,
                queries.DropRelation,
                queries.DropCredits,
                queries.DropUserCredits,
                queries.DropRewardCategories,
                queries.DropCategories,
                queries.DropTaskRewards,
                queries.DropRewards,
                queries.DropTasks,
                queries.DropUserProfiles,
                queries.DropUserRoles,
                queries.DropRoles,
                queries.DropUsers,
        }
}</span>

func (r *Repositories) DropTable(ctx context.Context) <span class="cov0" title="0">{
        dropTables := initDropTables()

        for _, drop := range dropTables </span><span class="cov0" title="0">{
                _, err := r.db.ExecContext(ctx, drop.ToString())
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error drop table : %s ", err.Error())
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package db

import (
        "context"
        "log"
        "task_mission/queries"
)

func initTableMigration() []queries.TableMigration <span class="cov0" title="0">{
        return []queries.TableMigration{
                queries.UserTableMigration,
                queries.UserProfileMigration,
                queries.RoleMigration,
                queries.UserRolesMigration,
                queries.TaskMigration,
                queries.CategoryMigration,
                queries.RewardMigration,
                queries.RewardCategoriesMigration,
                queries.TaskRewardMigration,
                queries.UserCreditsMigration,
                queries.CreditsMigration,
                queries.RelationMigration,
                queries.UserTaskMigration,
        }
}</span>

func (repo *Repositories) Migration(ctx context.Context) <span class="cov0" title="0">{
        migrations := initTableMigration()

        for _, migration := range migrations </span><span class="cov0" title="0">{
                _, err := repo.db.ExecContext(ctx, migration.ToString())
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error in migration : %s \n", err.Error())
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package db

import (
        "context"
        "task_mission/entities/models"
)

func (r *Repositories) SeedRole(ctx context.Context) <span class="cov0" title="0">{
        userRole := make(map[string]uint64)
        userRole["admin"] = 1
        userRole["user"] = 2
        userRole["super-user"] = 3
        for key, value := range userRole </span><span class="cov0" title="0">{
                role := &amp;models.Role{ID: value, Role: key}
                r.RoleRepository.Save(ctx, role)
        }</span>
}

func (r *Repositories) SeedCategory(ctx context.Context) <span class="cov0" title="0">{
        categories := []models.Category{
                {
                        Category: `Money`,
                },
                {
                        Category: `Card`,
                },
                {
                        Category: `Coupon`,
                },
        }

        for _, category := range categories </span><span class="cov0" title="0">{
                r.CategoryRepository.Save(ctx, &amp;category)
        }</span>
}</pre>
		
		<pre class="file" id="file38" style="display: none">package email

import (
        "bytes"
        "crypto/tls"
        "gopkg.in/gomail.v2"
        "html/template"
        "io/ioutil"
        "log"
        "os"
)

type Mailtrap struct {
        Dialer   *gomail.Dialer
        To       string
        Subject  string
        Metadata map[string]interface{}
}

func NewMailtrap(to, subject string, metadata map[string]interface{}) *Mailtrap <span class="cov0" title="0">{
        host := "sandbox.smtp.mailtrap.io"
        port := 587
        username := "4a87f6082d6054"
        password := "a711952511e0bf"

        log.Println("SMTP Host:", host)
        log.Println("SMTP Port:", port)
        log.Println("SMTP Username:", username)

        dialer := gomail.NewDialer(host, port, username, password)
        dialer.TLSConfig = &amp;tls.Config{InsecureSkipVerify: true}
        return &amp;Mailtrap{
                Dialer:   dialer,
                To:       to,
                Subject:  subject,
                Metadata: metadata,
        }
}</span>

func (e *Mailtrap) sendEmail(templatePath string) (err error) <span class="cov0" title="0">{
        htmlContent, err := ioutil.ReadFile(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to read HTML file: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">tmpl, err := template.New("emailTemplate").Parse(string(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to parse template: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">var body bytes.Buffer
        if err := tmpl.Execute(&amp;body, e.Metadata); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to execute template: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">mailer := gomail.NewMessage()
        mailer.SetHeader("From", os.Getenv("CONFIG_AUTH_EMAIL"))
        mailer.SetHeader("To", e.To)
        mailer.SetHeader("Subject", e.Subject)
        mailer.SetBody("text/html", body.String())

        log.Println("Sending email to:", e.To)
        if err := e.Dialer.DialAndSend(mailer); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to send email: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Println("Email sent successfully!")
        return nil</span>
}

func (e *Mailtrap) SendEmailRegister() error <span class="cov0" title="0">{
        return e.sendEmail("./scripts/email/register.html")
}</span>

func (e *Mailtrap) SendEmailTest() error <span class="cov0" title="0">{
        return e.sendEmail("./scripts/email/index.html")
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package email

import (
        "bytes"
        "github.com/sendgrid/rest"
        "github.com/sendgrid/sendgrid-go"
        "github.com/sendgrid/sendgrid-go/helpers/mail"
        "html/template"
        "io/ioutil"
        "log"
        "os"
)

type SendGrid struct {
        Client   *sendgrid.Client
        To       string
        Subject  string
        Metadata map[string]interface{}
}

func NewSendGrid(to, subject string, metadata map[string]interface{}) *SendGrid <span class="cov0" title="0">{
        apiKey := os.Getenv("SENDGRID_API_KEY")
        log.Println("Using SendGrid API Key:", apiKey)
        client := sendgrid.NewSendClient(apiKey)
        return &amp;SendGrid{
                Client:   client,
                To:       to,
                Subject:  subject,
                Metadata: metadata,
        }
}</span>

func (e *SendGrid) sendEmail(templatePath string) (*rest.Response, error) <span class="cov0" title="0">{
        htmlContent, err := ioutil.ReadFile(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to read HTML file: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">tmpl, err := template.New("emailTemplate").Parse(string(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to parse template: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var body bytes.Buffer
        if err := tmpl.Execute(&amp;body, e.Metadata); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to execute template: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">from := mail.NewEmail("From Sender", os.Getenv("CONFIG_AUTH_EMAIL"))
        to := mail.NewEmail("To Receiver", e.To)
        message := mail.NewSingleEmail(from, e.Subject, to, "", body.String())

        response, err := e.Client.Send(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to send email: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if response.StatusCode != 200 &amp;&amp; response.StatusCode != 202 </span><span class="cov0" title="0">{
                log.Printf("Email not sent. Status code: %d, response body: %s\n", response.StatusCode, response.Body)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Email sent successfully!")
        }</span>
        <span class="cov0" title="0">return response, nil</span>
}

func (e *SendGrid) SendEmailRegister() (*rest.Response, error) <span class="cov0" title="0">{
        return e.sendEmail("./scripts/email/register.html")
}</span>

func (e *SendGrid) SendEmailTest() (*rest.Response, error) <span class="cov0" title="0">{
        return e.sendEmail("./scripts/email/index.html")
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package firebases

import (
        "context"
        firebase "firebase.google.com/go/v4"
        "os"
)

type (
        Firebase interface {
                Store(ctx context.Context, path string) error
        }

        FirebaseConf struct {
                app *firebase.App
        }
)

func NewFirebaseConf(ctx context.Context) (*FirebaseConf, error) <span class="cov0" title="0">{
        app, err := firebase.NewApp(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;FirebaseConf{
                app: app,
        }, nil</span>
}

func (f *FirebaseConf) Store(ctx context.Context, path string) error <span class="cov0" title="0">{
        store, err := f.app.Storage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bucket, err := store.Bucket("gs://bulletinboard-37277.appspot.com")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        wc := bucket.Object(path).NewWriter(ctx)
        if _, err := wc.Write([]byte{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package grafana

import (
        "context"
        "errors"
        "go.opentelemetry.io/contrib/instrumentation/runtime"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/trace"
        "log"
        "time"
)

func SetupOTelSDK(ctx context.Context) (shutdown func(context.Context) error, err error) <span class="cov0" title="0">{
        var shutdownFuncs []func(context.Context) error

        // shutdown calls cleanup functions registered via shutdownFuncs.
        // The errors from the calls are joined.
        // Each registered cleanup will be invoked once.
        shutdown = func(ctx context.Context) error </span><span class="cov0" title="0">{
                var err error
                for _, fn := range shutdownFuncs </span><span class="cov0" title="0">{
                        err = errors.Join(err, fn(ctx))
                }</span>
                <span class="cov0" title="0">shutdownFuncs = nil
                return err</span>
        }

        // handleErr calls shutdown for cleanup and makes sure that all errors are returned.
        <span class="cov0" title="0">handleErr := func(inErr error) </span><span class="cov0" title="0">{
                err = errors.Join(inErr, shutdown(ctx))
        }</span>

        <span class="cov0" title="0">prop := propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        )
        otel.SetTextMapPropagator(prop)

        traceExporter, err := otlptrace.New(ctx, otlptracehttp.NewClient())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tracerProvider := trace.NewTracerProvider(trace.WithBatcher(traceExporter))
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
                return
        }</span>
        <span class="cov0" title="0">shutdownFuncs = append(shutdownFuncs, tracerProvider.Shutdown)
        otel.SetTracerProvider(tracerProvider)

        metricExporter, err := otlpmetrichttp.New(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">meterProvider := metric.NewMeterProvider(metric.WithReader(metric.NewPeriodicReader(metricExporter)))
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
                return
        }</span>
        <span class="cov0" title="0">shutdownFuncs = append(shutdownFuncs, meterProvider.Shutdown)
        otel.SetMeterProvider(meterProvider)

        err = runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package queries

type (
        GoQuery        string
        TableMigration string
        DropTable      string
)

func (d DropTable) ToString() string <span class="cov0" title="0">{
        return string(d)
}</span>

func (t TableMigration) ToString() string <span class="cov0" title="0">{
        return string(t)
}</span>

func (q GoQuery) ToString() string <span class="cov0" title="0">{
        return string(q)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type categoryRepository struct {
        db *sql.DB
}

func (c *categoryRepository) Save(ctx context.Context, request *models.Category) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.Category](ctx, c.db, queries.InsertIntoCategory, request.Category)
}</span>

func (c *categoryRepository) FindAll(ctx context.Context) (result []*models.Category, err error) <span class="cov0" title="0">{
        //category := &amp;models.Category{}
        result, err = utils.FindAll[models.Category](ctx, c.db, queries.SelectAllCategories)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (c *categoryRepository) Find(ctx context.Context, id uint64) (result *models.Category, err error) <span class="cov0" title="0">{
        result = &amp;models.Category{}
        err = utils.FindByID[models.Category](ctx, c.db, queries.SelectCategoryByID, id, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (c *categoryRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (c *categoryRepository) Update(ctx context.Context, request *models.Category) (result *models.Category, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func NewCategoryRepository(db *sql.DB) *categoryRepository <span class="cov0" title="0">{
        return &amp;categoryRepository{db: db}
}</span>

var _ repositories.ICategoryRepository = &amp;categoryRepository{}
</pre>
		
		<pre class="file" id="file44" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type creditRepository struct {
        db *sql.DB
}

func (c *creditRepository) GetUserCredits(ctx context.Context, userId uint64) (result []*models.Credit, err error) <span class="cov0" title="0">{
        rows, err := c.db.QueryContext(ctx, queries.SelectUserCredits.ToString(), userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                credit := &amp;models.Credit{}
                err = rows.Scan(
                        &amp;credit.ID,
                        &amp;credit.FromID,
                        &amp;credit.ToID,
                        &amp;credit.Credit,
                        &amp;credit.Description,
                        &amp;credit.CreatedAt,
                        &amp;credit.UpdatedAt,
                        &amp;credit.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, credit)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func (c *creditRepository) Save(ctx context.Context, request *models.Credit) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.Credit](ctx, c.db, queries.InsertCredit, request.FromID, request.ToID, request.Credit, request.Description)
}</span>

func (c *creditRepository) FindAll(ctx context.Context) (result []*models.Credit, err error) <span class="cov0" title="0">{
        result, err = utils.FindAll[models.Credit](ctx, c.db, queries.SelectAllCredits)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (c *creditRepository) Find(ctx context.Context, id uint64) (result *models.Credit, err error) <span class="cov0" title="0">{
        result = &amp;models.Credit{}
        err = utils.FindByID[models.Credit](ctx, c.db, queries.SelectCreditByID, id, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (c *creditRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (c *creditRepository) Update(ctx context.Context, request *models.Credit) (result *models.Credit, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func NewCreditRepository(db *sql.DB) *creditRepository <span class="cov0" title="0">{
        return &amp;creditRepository{
                db: db,
        }
}</span>

var _ repositories.ICreditRepository = &amp;creditRepository{}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/enums"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type relationRepository struct {
        db *sql.DB
}

func (r *relationRepository) FindUserFollowings(ctx context.Context, userId uint64) (result []*models.Relation, err error) <span class="cov0" title="0">{
        return r.findUserRelation(ctx, queries.SelectFollowingRelations, userId)
}</span>

func (r *relationRepository) FindRelationWithFriend(ctx context.Context, userId uint64, friendId uint64) (result *models.Relation, err error) <span class="cov0" title="0">{
        result = &amp;models.Relation{}
        err = r.db.QueryRowContext(ctx, queries.SelectUserFriendRelation.ToString(), userId, friendId).Scan(
                &amp;result.ID,
                &amp;result.UserID,
                &amp;result.FriendID,
                &amp;result.RelationStatus,
                &amp;result.CreatedAt,
                &amp;result.UpdatedAt,
                &amp;result.DeletedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *relationRepository) FindUserFollowers(ctx context.Context, userId uint64) (result []*models.Relation, err error) <span class="cov0" title="0">{
        return r.findUserRelation(ctx, queries.SelectFollowersRelations, userId)
}</span>

func (r *relationRepository) Save(ctx context.Context, request *models.Relation) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.Relation](ctx, r.db, queries.InsertIntoRelation, request.UserID, request.FriendID, enums.Following)
}</span>

func (r *relationRepository) FindAll(ctx context.Context) (result []*models.Relation, err error) <span class="cov0" title="0">{
        //var relation = &amp;models.Relation{}
        return utils.FindAll[models.Relation](ctx, r.db, queries.SelectAllRelations)
}</span>

func (r *relationRepository) Find(ctx context.Context, id uint64) (result *models.Relation, err error) <span class="cov0" title="0">{
        result = &amp;models.Relation{}
        err = utils.FindByID[models.Relation](ctx, r.db, queries.SelectRelationByID, id, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *relationRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *relationRepository) Update(ctx context.Context, request *models.Relation) (result *models.Relation, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *relationRepository) findUserRelation(ctx context.Context, query queries.GoQuery, userId uint64) (result []*models.Relation, err error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx, query.ToString(), userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                relation := &amp;models.Relation{}
                rows.Scan(
                        &amp;relation.ID,
                        &amp;relation.UserID,
                        &amp;relation.FriendID,
                        &amp;relation.RelationStatus,
                        &amp;relation.CreatedAt,
                        &amp;relation.UpdatedAt,
                        &amp;relation.DeletedAt,
                )
                result = append(result, relation)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func NewRelationRepository(db *sql.DB) *relationRepository <span class="cov0" title="0">{
        return &amp;relationRepository{db: db}
}</span>

var _ repositories.IRelationRepository = &amp;relationRepository{}
</pre>
		
		<pre class="file" id="file46" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type rewardCategoryRepository struct {
        db *sql.DB
}

func (r *rewardCategoryRepository) FindByRewardID(ctx context.Context, rewardID uint64) ([]*models.RewardCategory, error) <span class="cov0" title="0">{
        return r.findByConditionId(ctx, queries.SelectByRewardID, rewardID)
}</span>

func (r *rewardCategoryRepository) FindByCategoryID(ctx context.Context, categoryID uint64) ([]*models.RewardCategory, error) <span class="cov0" title="0">{
        return r.findByConditionId(ctx, queries.SelectByCategoryID, categoryID)
}</span>

func (r *rewardCategoryRepository) Save(ctx context.Context, request *models.RewardCategory) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.RewardCategory](ctx, r.db, queries.InsertIntoRewardCategory, &amp;request.RewardID, &amp;request.CategoryID)
}</span>

func (r *rewardCategoryRepository) FindAll(ctx context.Context) (result []*models.RewardCategory, err error) <span class="cov0" title="0">{
        //rewardCategory := &amp;models.RewardCategory{}
        result, err = utils.FindAll[models.RewardCategory](ctx, r.db, queries.SelectFromRewardCategory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *rewardCategoryRepository) Find(ctx context.Context, id uint64) (result *models.RewardCategory, err error) <span class="cov0" title="0">{
        return
}</span>

func (r *rewardCategoryRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *rewardCategoryRepository) Update(ctx context.Context, request *models.RewardCategory) (result *models.RewardCategory, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *rewardCategoryRepository) findByConditionId(ctx context.Context, query queries.GoQuery, conditionId uint64) ([]*models.RewardCategory, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx, query.ToString(), conditionId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rewardCategoryList := make([]*models.RewardCategory, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                rewardCategory := &amp;models.RewardCategory{}
                err = rows.Scan(&amp;rewardCategory.ID, &amp;rewardCategory.RewardID, &amp;rewardCategory.CategoryID, &amp;rewardCategory.CreatedAt, &amp;rewardCategory.UpdatedAt, &amp;rewardCategory.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rewardCategoryList = append(rewardCategoryList, rewardCategory)</span>
        }
        <span class="cov0" title="0">return rewardCategoryList, nil</span>
}

func NewRewardCategoryRepository(db *sql.DB) *rewardCategoryRepository <span class="cov0" title="0">{
        return &amp;rewardCategoryRepository{db: db}
}</span>

var _ repositories.IRewardCategoryRepository = &amp;rewardCategoryRepository{}
</pre>
		
		<pre class="file" id="file47" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type rewardRepository struct {
        db *sql.DB
}

func (r *rewardRepository) Save(ctx context.Context, request *models.Reward) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.Reward](ctx, r.db, queries.InsertIntoReward, &amp;request.Name, &amp;request.Description, &amp;request.Image, &amp;request.UserID)
}</span>

func (r *rewardRepository) FindAll(ctx context.Context) (result []*models.Reward, err error) <span class="cov0" title="0">{
        //var reward = &amp;models.Reward{}
        result, err = utils.FindAll[models.Reward](ctx, r.db, queries.SelectAllRewards)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *rewardRepository) Find(ctx context.Context, id uint64) (result *models.Reward, err error) <span class="cov0" title="0">{
        result = &amp;models.Reward{}
        err = utils.FindByID[models.Reward](ctx, r.db, queries.SelectRewardByID, id, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *rewardRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *rewardRepository) Update(ctx context.Context, request *models.Reward) (result *models.Reward, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func NewRewardRepository(db *sql.DB) *rewardRepository <span class="cov0" title="0">{
        return &amp;rewardRepository{db: db}
}</span>

var _ repositories.IRewardRepository = &amp;rewardRepository{}
</pre>
		
		<pre class="file" id="file48" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type roleRepository struct {
        db *sql.DB
}

func (r roleRepository) Save(ctx context.Context, request *models.Role) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.Role](ctx, r.db, queries.InsertRole, request.ID, request.Role)
}</span>

func (r roleRepository) FindAll(ctx context.Context) (result []*models.Role, err error) <span class="cov0" title="0">{
        return
}</span>

func (r roleRepository) Find(ctx context.Context, id uint64) (result *models.Role, err error) <span class="cov0" title="0">{
        return
}</span>

func (r roleRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        return
}</span>

func (r roleRepository) Update(ctx context.Context, request *models.Role) (result *models.Role, err error) <span class="cov0" title="0">{
        return
}</span>

func NewRoleRepository(db *sql.DB) *roleRepository <span class="cov0" title="0">{
        return &amp;roleRepository{
                db: db,
        }
}</span>

var _ repositories.IRoleRepository = &amp;roleRepository{}
</pre>
		
		<pre class="file" id="file49" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type taskRepository struct {
        db *sql.DB
}

func (t *taskRepository) Save(ctx context.Context, request *models.Task) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.Task](ctx, t.db, queries.InsertTask, request.Title, request.Description, request.Image, request.UserID, request.ExpiredDate, request.Status)
}</span>

func (t *taskRepository) FindAll(ctx context.Context) (result []*models.Task, err error) <span class="cov0" title="0">{
        result, err = utils.FindAll[models.Task](ctx, t.db, queries.SelectAllTasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (t *taskRepository) Find(ctx context.Context, id uint64) (result *models.Task, err error) <span class="cov0" title="0">{
        result = &amp;models.Task{}
        err = utils.FindByID[models.Task](ctx, t.db, queries.SelectTaskByID, id, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (t *taskRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (t *taskRepository) Update(ctx context.Context, request *models.Task) (result *models.Task, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

var _ repositories.ITaskRepository = &amp;taskRepository{}

func NewTaskRepository(db *sql.DB) *taskRepository <span class="cov0" title="0">{
        return &amp;taskRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type taskRewardRepository struct {
        db *sql.DB
}

func (t *taskRewardRepository) FindByTaskId(ctx context.Context, taskId uint64) (result *models.TaskReward, err error) <span class="cov0" title="0">{
        result = &amp;models.TaskReward{}
        err = t.db.QueryRowContext(ctx, queries.SelectTaskRewardByTaskID.ToString(), taskId).Scan(
                &amp;result.ID,
                &amp;result.TaskID,
                &amp;result.RewardID,
                &amp;result.CreatedAt, &amp;result.UpdatedAt, &amp;result.DeletedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (t *taskRewardRepository) Save(ctx context.Context, request *models.TaskReward) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.TaskReward](ctx, t.db, queries.InsertIntoTaskReward, request.TaskID, request.RewardID)
}</span>

func (t *taskRewardRepository) FindAll(ctx context.Context) (result []*models.TaskReward, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (t *taskRewardRepository) Find(ctx context.Context, id uint64) (result *models.TaskReward, err error) <span class="cov0" title="0">{

        return
}</span>

func (t *taskRewardRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (t *taskRewardRepository) Update(ctx context.Context, request *models.TaskReward) (result *models.TaskReward, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (t *taskRewardRepository) FindByRewardId(ctx context.Context, rewardId uint64) (result *models.TaskReward, err error) <span class="cov0" title="0">{
        result = &amp;models.TaskReward{}
        err = t.db.QueryRowContext(ctx, queries.SelectTaskRewardByRewardID.ToString(), rewardId).Scan(
                &amp;result.ID,
                &amp;result.TaskID,
                &amp;result.RewardID,
                &amp;result.CreatedAt, &amp;result.UpdatedAt, &amp;result.DeletedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func NewTaskRewardRepository(db *sql.DB) *taskRewardRepository <span class="cov0" title="0">{
        return &amp;taskRewardRepository{db: db}
}</span>

var _ repositories.ITaskRewardRepository = &amp;taskRewardRepository{}
</pre>
		
		<pre class="file" id="file51" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/interfaces/repositories"
)

type (
        unitOfWork struct {
                conn interface{}
        }
)

func NewUnitOfWork(db *sql.DB) *unitOfWork <span class="cov0" title="0">{
        return &amp;unitOfWork{conn: db}
}</span>

func (uow *unitOfWork) Begin(ctx context.Context) (repositories.UnitOfWork, error) <span class="cov0" title="0">{
        switch c := uow.conn.(type) </span>{
        case *sql.DB:<span class="cov0" title="0">
                tx, err := uow.conn.(*sql.DB).BeginTx(ctx, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">uow.conn = tx</span>
        case *sql.Tx:<span class="cov0" title="0">
                uow.conn = c</span>
        }
        <span class="cov0" title="0">return uow, nil</span>
}

func (uow *unitOfWork) Rollback() error <span class="cov0" title="0">{
        tx, ok := uow.conn.(*sql.Tx)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return tx.Rollback()</span>
}

func (uow *unitOfWork) Commit() error <span class="cov0" title="0">{
        tx, ok := uow.conn.(*sql.Tx)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return tx.Commit()</span>
}

func (uow *unitOfWork) NewUserRepository() repositories.IUserRepository <span class="cov0" title="0">{
        return NewUserRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewRoleRepository() repositories.IRoleRepository <span class="cov0" title="0">{
        return NewRoleRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewCategoryRepository() repositories.ICategoryRepository <span class="cov0" title="0">{
        return NewCategoryRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewUserProfileRepository() repositories.IUserProfileRepository <span class="cov0" title="0">{
        return NewUserProfileRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewUserRoleRepository() repositories.IUserRoleRepository <span class="cov0" title="0">{
        return NewUserRoleRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewTaskRepository() repositories.ITaskRepository <span class="cov0" title="0">{
        return NewTaskRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewRewardRepository() repositories.IRewardRepository <span class="cov0" title="0">{
        return NewRewardRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewTaskRewardRepository() repositories.ITaskRewardRepository <span class="cov0" title="0">{
        return NewTaskRewardRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewRewardCategoryRepository() repositories.IRewardCategoryRepository <span class="cov0" title="0">{
        return NewRewardCategoryRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewUserCreditRepository() repositories.IUserCreditRepository <span class="cov0" title="0">{
        return NewUserCreditRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewUserTaskRepository() repositories.IUserTaskRepository <span class="cov0" title="0">{
        return NewUserTaskRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewRelationRepository() repositories.IRelationRepository <span class="cov0" title="0">{
        return NewRelationRepository(uow.conn.(*sql.DB))
}</span>

func (uow *unitOfWork) NewCreditRepository() repositories.ICreditRepository <span class="cov0" title="0">{
        return NewCreditRepository(uow.conn.(*sql.DB))
}</span>

var _ repositories.UnitOfWork = &amp;unitOfWork{}
</pre>
		
		<pre class="file" id="file52" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type userCreditRepository struct {
        db *sql.DB
}

func (u userCreditRepository) Save(ctx context.Context, request *models.UserCredit) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.UserCredit](ctx, u.db, queries.InsertUserCredit, &amp;request.UserID)
}</span>

func (u userCreditRepository) FindAll(ctx context.Context) (result []*models.UserCredit, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u userCreditRepository) Find(ctx context.Context, id uint64) (result *models.UserCredit, err error) <span class="cov0" title="0">{
        return
}</span>

func (u userCreditRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u userCreditRepository) Update(ctx context.Context, request *models.UserCredit) (result *models.UserCredit, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

var _ repositories.IUserCreditRepository = &amp;userCreditRepository{}

func NewUserCreditRepository(db *sql.DB) *userCreditRepository <span class="cov0" title="0">{
        return &amp;userCreditRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type userProfileRepository struct {
        db *sql.DB
}

func (u *userProfileRepository) FindByEmail(ctx context.Context, email string) (result *models.UserProfile, err error) <span class="cov0" title="0">{
        result = &amp;models.UserProfile{}
        err = u.db.QueryRowContext(ctx, queries.SelectUserProfileByEmail, email).Scan(
                &amp;result.ID, &amp;result.Email, &amp;result.Password, &amp;result.Image, &amp;result.UserID,
                &amp;result.CreatedAt, &amp;result.UpdatedAt, &amp;result.DeletedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (u *userProfileRepository) Save(ctx context.Context, request *models.UserProfile) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.UserProfile](ctx, u.db, queries.InsertUserProfile, &amp;request.Email, &amp;request.Password, &amp;request.Image, &amp;request.UserID)
}</span>

func (u *userProfileRepository) FindAll(ctx context.Context) (result []*models.UserProfile, err error) <span class="cov0" title="0">{
        //var userProfile = &amp;models.UserProfile{}
        return utils.FindAll[models.UserProfile](ctx, u.db, queries.SelectAllUserProfiles)
}</span>

func (u *userProfileRepository) FindByUserID(ctx context.Context, userId uint64) (result *models.UserProfile, err error) <span class="cov0" title="0">{
        result = &amp;models.UserProfile{}
        err = utils.FindByID[models.UserProfile](ctx, u.db, queries.SelectUserProfileByUserID, userId, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (u *userProfileRepository) Find(ctx context.Context, id uint64) (result *models.UserProfile, err error) <span class="cov0" title="0">{

        //err = utils.FindByID[models.UserProfile](ctx, u.db, queries.SelectUserProfileByID, id)
        return
}</span>

func (u *userProfileRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userProfileRepository) Update(ctx context.Context, request *models.UserProfile) (result *models.UserProfile, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

var _ repositories.IUserProfileRepository = &amp;userProfileRepository{}

func NewUserProfileRepository(db *sql.DB) *userProfileRepository <span class="cov0" title="0">{
        return &amp;userProfileRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type userRepository struct {
        db *sql.DB
}

func (u *userRepository) Save(ctx context.Context, request *models.User) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.User](ctx, u.db, queries.InsertUser, &amp;request.Name, &amp;request.UserName, &amp;request.DateOfBirth, request.Gender.ToString())
}</span>

func (u *userRepository) FindAll(ctx context.Context) (result []*models.User, err error) <span class="cov0" title="0">{
        return utils.FindAll[models.User](ctx, u.db, queries.SelectAllUser)
}</span>

func (u *userRepository) Find(ctx context.Context, id uint64) (result *models.User, err error) <span class="cov0" title="0">{
        result = &amp;models.User{}
        err = utils.FindByID[models.User](ctx, u.db, queries.SelectUserByID, id, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (u *userRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        return utils.Delete[models.User](ctx, u.db, queries.DeleteUser, id)
}</span>

func (u *userRepository) Update(ctx context.Context, request *models.User) (*models.User, error) <span class="cov0" title="0">{
        err := utils.Update[models.User](ctx, u.db, queries.UpdateUser, &amp;request.Name, &amp;request.UserName, &amp;request.DateOfBirth, &amp;request.Gender, &amp;request.IsVerified, &amp;request.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return request, nil</span>
}

var _ repositories.IUserRepository = &amp;userRepository{}

func NewUserRepository(db *sql.DB) *userRepository <span class="cov0" title="0">{
        return &amp;userRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type userRoleRepository struct {
        db *sql.DB
}

func (u *userRoleRepository) FindByUserID(ctx context.Context, userId uint64) (result *models.UserRole, err error) <span class="cov0" title="0">{
        result = &amp;models.UserRole{}
        err = u.db.QueryRowContext(ctx, queries.SelectUserRoleByUserID, userId).Scan(&amp;result.ID, &amp;result.UserID, &amp;result.RoleID, &amp;result.CreatedAt, &amp;result.UpdatedAt, &amp;result.DeletedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (u *userRoleRepository) Save(ctx context.Context, request *models.UserRole) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.UserRole](ctx, u.db, queries.InsertUserRole, &amp;request.UserID, &amp;request.RoleID)
}</span>

func (u *userRoleRepository) FindAll(ctx context.Context) (result []*models.UserRole, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userRoleRepository) Find(ctx context.Context, id uint64) (result *models.UserRole, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userRoleRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userRoleRepository) Update(ctx context.Context, request *models.UserRole) (result *models.UserRole, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

var _ repositories.IUserRoleRepository = &amp;userRoleRepository{}

func NewUserRoleRepository(db *sql.DB) *userRoleRepository <span class="cov0" title="0">{
        return &amp;userRoleRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/queries"
        "task_mission/utils"
)

type userTaskRepository struct {
        db *sql.DB
}

func (u *userTaskRepository) Save(ctx context.Context, request *models.UserTask) (result *uint64, err error) <span class="cov0" title="0">{
        return utils.Save[models.UserTask](ctx, u.db, queries.InsertUserTask, request.UserID, request.TaskID)
}</span>

func (u *userTaskRepository) FindAll(ctx context.Context) (result []*models.UserTask, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userTaskRepository) Find(ctx context.Context, id uint64) (result *models.UserTask, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userTaskRepository) Delete(ctx context.Context, id uint64) (err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (u *userTaskRepository) Update(ctx context.Context, request *models.UserTask) (result *models.UserTask, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

var _ repositories.IUserTaskRepository = &amp;userTaskRepository{}

func NewUserTaskRepository(db *sql.DB) *userTaskRepository <span class="cov0" title="0">{
        return &amp;userTaskRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package usecases

import (
        "context"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/entities/dtos/responses"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/interfaces/usecases"
)

type categoryUsecase struct {
        categoryRepository       repositories.ICategoryRepository
        rewardRepository         repositories.IRewardRepository
        rewardCategoryRepository repositories.IRewardCategoryRepository
}

func (c *categoryUsecase) CreateCategory(ctx context.Context, request *requests.CategoryRequest) (result *responses.CategoryResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        category := &amp;models.Category{
                Category: request.Category,
        }
        id, err := c.categoryRepository.Save(ctx, category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to create category`, err)
        }</span>
        <span class="cov0" title="0">category, err = c.categoryRepository.Find(ctx, *id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find category`, err)
        }</span>
        <span class="cov0" title="0">result = responses.NewCategoryListResponse(category)
        return result, nil</span>
}

func (c *categoryUsecase) GetAllCategories(ctx context.Context) (result []*responses.CategoryResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        categories, err := c.categoryRepository.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find categories`, err)
        }</span>
        <span class="cov0" title="0">result = responses.NewCategoryListResponses(categories)
        return result, nil</span>
}

func (c *categoryUsecase) GetCategoryById(ctx context.Context, categoryId uint64) (result *responses.CategoryDetailResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        category, err := c.categoryRepository.Find(ctx, categoryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find category`, err)
        }</span>

        <span class="cov0" title="0">categoryRewards, err := c.rewardCategoryRepository.FindByCategoryID(ctx, category.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find reward category`, err)
        }</span>

        <span class="cov0" title="0">var rewards []*models.Reward
        for _, categoryReward := range categoryRewards </span><span class="cov0" title="0">{
                reward, err := c.rewardRepository.Find(ctx, categoryReward.RewardID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find category`, err)
                }</span>
                <span class="cov0" title="0">rewards = append(rewards, reward)</span>
        }

        <span class="cov0" title="0">result = responses.NewCategoryDetailResponse(category, rewards)
        return result, nil</span>
}

var _ usecases.ICategoryUsecase = &amp;categoryUsecase{}

func NewCategoryUsecase(
        categoryRepository repositories.ICategoryRepository,
        rewardRepository repositories.IRewardRepository,
        rewardCategoryRepository repositories.IRewardCategoryRepository) *categoryUsecase <span class="cov0" title="0">{
        return &amp;categoryUsecase{
                categoryRepository:       categoryRepository,
                rewardRepository:         rewardRepository,
                rewardCategoryRepository: rewardCategoryRepository,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package usecases

import (
        "context"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/entities/dtos/responses"
        "task_mission/entities/models"
        "task_mission/enums"
        "task_mission/interfaces/repositories"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type creditUsecase struct {
        userRepository       repositories.IUserRepository
        creditRepository     repositories.ICreditRepository
        userCreditRepository repositories.IUserCreditRepository
}

func (c *creditUsecase) GiveCredit(ctx context.Context, request *requests.CreditRequest) (response *responses.UserCreditResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        userId := ctx.Value(enums.UserID).(uint64)
        user, err := c.userRepository.Find(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
        }</span>
        <span class="cov0" title="0">toUser, err := c.userRepository.Find(ctx, request.ToUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
        }</span>
        <span class="cov0" title="0">credit := &amp;models.Credit{
                FromID:      user.ID,
                ToID:        toUser.ID,
                Credit:      request.Credit,
                Description: request.Description,
        }
        cId, err := c.creditRepository.Save(ctx, credit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to insert credit`, err)
        }</span>
        <span class="cov0" title="0">credit, err = c.creditRepository.Find(ctx, *cId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find credit`, err)
        }</span>
        <span class="cov0" title="0">response = &amp;responses.UserCreditResponse{
                Credit: credit.Credit,
                UserID: toUser.ID,
        }
        return response, nil</span>
}

func (c *creditUsecase) SeeUserCredit(ctx context.Context, userId uint64) (response *responses.UserCreditResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        user, err := c.userRepository.Find(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
        }</span>
        <span class="cov0" title="0">credits, err := c.creditRepository.GetUserCredits(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user credits`, err)
        }</span>
        <span class="cov0" title="0">creditAvg := utils.CreditsAverage(credits)
        response = &amp;responses.UserCreditResponse{
                UserID: user.ID,
                Credit: creditAvg,
        }
        return response, nil</span>
}

func (c *creditUsecase) SeeAllCredits(ctx context.Context) (result []*responses.UserCreditResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        credits, err := c.creditRepository.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user credits`, err)
        }</span>
        <span class="cov0" title="0">creditMap := make(map[uint64][]*models.Credit)
        for _, credit := range credits </span><span class="cov0" title="0">{
                creditMap[credit.ToID] = append(creditMap[credit.ToID], credit)
        }</span>
        <span class="cov0" title="0">for toID, credits := range creditMap </span><span class="cov0" title="0">{
                creditAvg := utils.CreditsAverage(credits)
                response := &amp;responses.UserCreditResponse{
                        UserID: toID,
                        Credit: creditAvg,
                }
                result = append(result, response)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

var _ usecases.ICreditUseCase = &amp;creditUsecase{}

func NewCreditUsecase(
        userRepository repositories.IUserRepository,
        creditRepository repositories.ICreditRepository,
        userCreditRepository repositories.IUserCreditRepository) *creditUsecase <span class="cov0" title="0">{
        return &amp;creditUsecase{
                userRepository:       userRepository,
                creditRepository:     creditRepository,
                userCreditRepository: userCreditRepository,
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package usecases

import (
        "context"
        "log"
        "sync"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/entities/dtos/responses"
        "task_mission/entities/models"
        "task_mission/enums"
        "task_mission/interfaces/repositories"
        "task_mission/interfaces/usecases"
        "task_mission/utils"
)

type relationUsecase struct {
        uow          repositories.UnitOfWork
        relationRepo repositories.IRelationRepository
        userRepo     repositories.IUserRepository
        creditRepo   repositories.ICreditRepository
}

func (r *relationUsecase) SeeAllFollowers(ctx context.Context) (result []*responses.FollowerResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        userId := ctx.Value(enums.UserID).(uint64)
        followers, err := r.relationRepo.FindUserFollowers(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get followers`, err)
        }</span>
        <span class="cov0" title="0">for _, follower := range followers </span><span class="cov0" title="0">{
                user, err := r.userRepo.Find(ctx, follower.FriendID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
                }</span>
                <span class="cov0" title="0">credits, err := r.creditRepo.GetUserCredits(ctx, user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get credits`, err)
                }</span>
                <span class="cov0" title="0">creditAvg := utils.CreditsAverage(credits)
                response := &amp;responses.FollowerResponse{
                        ID:        user.ID,
                        Name:      user.Name,
                        UserName:  user.UserName,
                        UserScore: creditAvg,
                        CreatedAt: user.CreatedAt,
                        UpdatedAt: user.UpdatedAt,
                        DeletedAt: user.DeletedAt,
                }
                result = append(result, response)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func (r *relationUsecase) SeeAllFollowings(ctx context.Context) (result []*responses.FollowingResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        userId := ctx.Value(enums.UserID).(uint64)
        followings, err := r.relationRepo.FindUserFollowings(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get followings`, err)
        }</span>
        <span class="cov0" title="0">log.Println(followings[0])
        for _, following := range followings </span><span class="cov0" title="0">{
                friend, err := r.userRepo.Find(ctx, following.FriendID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get friend`, err)
                }</span>
                <span class="cov0" title="0">credits, err := r.creditRepo.GetUserCredits(ctx, friend.ID)
                if err != nil </span><span class="cov0" title="0">{
                        credits = []*models.Credit{}
                }</span>
                <span class="cov0" title="0">creditAvg := utils.CreditsAverage(credits)
                response := &amp;responses.FollowingResponse{
                        ID:        friend.ID,
                        Name:      friend.Name,
                        UserName:  friend.UserName,
                        UserScore: creditAvg,
                        CreatedAt: friend.CreatedAt,
                        UpdatedAt: friend.UpdatedAt,
                        DeletedAt: friend.DeletedAt,
                }
                result = append(result, response)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func (r *relationUsecase) AddFriend(ctx context.Context, request *requests.FriendRequest) (result *responses.CreateFriendResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        var (
                wg     sync.WaitGroup
                user   = &amp;models.User{}
                friend = &amp;models.User{}
                userId = ctx.Value(enums.UserID).(uint64)
                errCh  = make(chan *apperror.CustomError, 2)
                err    error
        )
        log.Println(userId)
        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                user, err = r.userRepo.Find(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                friend, err = r.userRepo.Find(ctx, request.FriendID)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get friend`, err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">wg.Wait()
        close(errCh)

        for customErr = range errCh </span><span class="cov0" title="0">{
                if &amp;customErr != nil </span><span class="cov0" title="0">{
                        return nil, customErr
                }</span>
        }

        <span class="cov0" title="0">relation := &amp;models.Relation{
                UserID:   user.ID,
                FriendID: friend.ID,
        }

        relationId, err := r.relationRepo.Save(ctx, relation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to create user relation`, err)
        }</span>

        <span class="cov0" title="0">relation, err = r.relationRepo.Find(ctx, *relationId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get relation`, err)
        }</span>

        <span class="cov0" title="0">result = &amp;responses.CreateFriendResponse{
                ID:         *relationId,
                UserID:     user.ID,
                UserName:   user.UserName,
                FriendID:   friend.ID,
                FriendName: friend.UserName,
                CreatedAt:  relation.CreatedAt,
                UpdatedAt:  relation.UpdatedAt,
                DeletedAt:  relation.DeletedAt,
        }

        return</span>
}

func (r *relationUsecase) SeeAllFriends(ctx context.Context) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func NewRelationUsecase(
        uow repositories.UnitOfWork,
        relationRepo repositories.IRelationRepository,
        userRepo repositories.IUserRepository,
        creditRepo repositories.ICreditRepository,
) *relationUsecase <span class="cov0" title="0">{
        return &amp;relationUsecase{
                uow:          uow,
                relationRepo: relationRepo,
                userRepo:     userRepo,
                creditRepo:   creditRepo,
        }
}</span>

var _ usecases.IRelationUsecase = &amp;relationUsecase{}
</pre>
		
		<pre class="file" id="file60" style="display: none">package usecases

import (
        "context"
        "log"
        "sync"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/entities/dtos/responses"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/interfaces/usecases"
)

type rewardUsecase struct {
        uow                repositories.UnitOfWork
        rewardRepo         repositories.IRewardRepository
        taskRepo           repositories.ITaskRepository
        userRepo           repositories.IUserRepository
        userProfileRepo    repositories.IUserProfileRepository
        categoryRepo       repositories.ICategoryRepository
        rewardCategoryRepo repositories.IRewardCategoryRepository
        taskRewardRepo     repositories.ITaskRewardRepository
}

func (r *rewardUsecase) CreateReward(ctx context.Context, request *requests.CreateRewardRequest) (result *models.Reward, customerr *apperror.CustomError) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *rewardUsecase) GetAllRewards(ctx context.Context) (result []*responses.RewardListResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        rewards, err := r.rewardRepo.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, ``, err)
        }</span>
        <span class="cov0" title="0">result = responses.NewRewardListResponses(rewards)
        return result, nil</span>
}

func (r *rewardUsecase) GetRewardByID(ctx context.Context, id uint64) (result *responses.RewardDetailResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        reward, err := r.rewardRepo.Find(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, ``, err)
        }</span>

        <span class="cov0" title="0">var (
                wg              sync.WaitGroup
                errCh           = make(chan *apperror.CustomError)
                categoryRewards = make([]*models.RewardCategory, 0)
                category        = &amp;models.Category{}
                categories      = make([]*models.Category, 0)
                task            = &amp;models.Task{}
                user            = &amp;models.User{}
                profile         = &amp;models.UserProfile{}
                taskReward      = &amp;models.TaskReward{}
        )

        wg.Add(3)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                categoryRewards, err = r.rewardCategoryRepo.FindByRewardID(ctx, reward.ID)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get category reward`, err)
                        return
                }</span>

                <span class="cov0" title="0">for _, categoryReward := range categoryRewards </span><span class="cov0" title="0">{
                        log.Println(categoryReward.RewardID, " ", categoryReward.CategoryID)
                        category, err = r.categoryRepo.Find(ctx, categoryReward.CategoryID)
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get category`, err)
                                return
                        }</span>
                        <span class="cov0" title="0">categories = append(categories, category)</span>
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()

                taskReward, err = r.taskRewardRepo.FindByRewardId(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get task reward`, err)
                        return
                }</span>
                <span class="cov0" title="0">task, err = r.taskRepo.Find(ctx, taskReward.TaskID)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get task`, err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                user, err = r.userRepo.Find(ctx, reward.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
                        return
                }</span>

                <span class="cov0" title="0">profile, err = r.userProfileRepo.FindByUserID(ctx, user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user profile`, err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errCh)
        }</span>()

        <span class="cov0" title="0">for errC := range errCh </span><span class="cov0" title="0">{
                return nil, errC
        }</span>

        <span class="cov0" title="0">result = responses.NewRewardDetailResponse(reward, user, profile, task, categories)

        return result, nil</span>
}

var _ usecases.IRewardUsecase = &amp;rewardUsecase{}

func NewRewardUsecase(
        uow repositories.UnitOfWork,
        rewardRepo repositories.IRewardRepository,
        taskRepo repositories.ITaskRepository,
        userRepo repositories.IUserRepository,
        userProfileRepo repositories.IUserProfileRepository,
        categoryRepo repositories.ICategoryRepository,
        rewardCategoryRepo repositories.IRewardCategoryRepository,
        taskRewardRepo repositories.ITaskRewardRepository,
) *rewardUsecase <span class="cov0" title="0">{
        return &amp;rewardUsecase{
                uow:                uow,
                rewardRepo:         rewardRepo,
                taskRepo:           taskRepo,
                userRepo:           userRepo,
                categoryRepo:       categoryRepo,
                userProfileRepo:    userProfileRepo,
                rewardCategoryRepo: rewardCategoryRepo,
                taskRewardRepo:     taskRewardRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package usecases

import (
        "context"
        "fmt"
        "sync"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/entities/dtos/responses"
        "task_mission/entities/models"
        "task_mission/enums"
        "task_mission/interfaces/repositories"
        "task_mission/interfaces/usecases"
        "task_mission/pkg/firebases"
)

type taskUsecase struct {
        taskRepo           repositories.ITaskRepository
        rewardRepo         repositories.IRewardRepository
        taskRewardRepo     repositories.ITaskRewardRepository
        rewardCategoryRepo repositories.IRewardCategoryRepository
        userRepo           repositories.IUserRepository
        userProfileRepo    repositories.IUserProfileRepository
        userTaskRepo       repositories.IUserTaskRepository
        firebaseConf       firebases.Firebase
        uow                repositories.UnitOfWork
}

func (t *taskUsecase) GetTaskDetail(ctx context.Context, taskID uint64) (result *responses.TaskDetailResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        var (
                uID         = ctx.Value(enums.UserID).(uint64)
                wg          = &amp;sync.WaitGroup{}
                task        = &amp;models.Task{}
                reward      = &amp;models.Reward{}
                taskReward  = &amp;models.TaskReward{}
                user        = &amp;models.User{}
                userProfile = &amp;models.UserProfile{}
                err         error
                errChan     = make(chan error, 2)
        )
        //t.firebaseConf.Store(ctx, "")
        wg.Add(2)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                user, err = t.userRepo.Find(ctx, uID)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">userProfile, err = t.userProfileRepo.FindByUserID(ctx, user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                task, err = t.taskRepo.Find(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">taskReward, err = t.taskRewardRepo.FindByTaskId(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">reward, err = t.rewardRepo.Find(ctx, taskReward.RewardID)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">wg.Wait()

        select </span>{
        case err = &lt;-errChan:<span class="cov0" title="0">
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get reward detail`, err)</span>
        default:<span class="cov0" title="0">
                result = responses.NewTaskDetailResponse(task, user, userProfile, reward)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (t *taskUsecase) TakeTask(ctx context.Context, taskID uint64) (result *responses.UserTaskResponse, err error) <span class="cov0" title="0">{
        var (
                wg    sync.WaitGroup
                user  = &amp;models.User{}
                task  = &amp;models.Task{}
                errCh = make(chan error, 2)
        )

        t.uow, err = t.uow.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        err = t.uow.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">err = t.uow.Commit()</span>
        }()
        <span class="cov0" title="0">userId := ctx.Value(enums.UserID).(uint64)

        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                user, err = t.userRepo.Find(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                task, err = t.taskRepo.Find(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errCh)
        }</span>()

        <span class="cov0" title="0">for err := range errCh </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to process the concurrency`, err)
                }</span>
        }

        <span class="cov0" title="0">userTask := &amp;models.UserTask{
                UserID: user.ID,
                TaskID: task.ID,
        }
        userTaskId, err := t.userTaskRepo.Save(ctx, userTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to create user task`, err)
        }</span>
        <span class="cov0" title="0">userTask, err = t.userTaskRepo.Find(ctx, *userTaskId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to find user task`, err)
        }</span>
        <span class="cov0" title="0">result = responses.NewUserTaskResponse(userTask)
        return result, nil</span>
}

func (t *taskUsecase) CreateTask(ctx context.Context, request *requests.CreateTaskRequest) (result *responses.TaskResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        uow, err := t.uow.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to begin trx`, err)
        }</span>
        <span class="cov0" title="0">t.uow = uow
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        err := t.uow.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">err = t.uow.Commit()</span>

        }()
        <span class="cov0" title="0">uId := ctx.Value(enums.UserID).(uint64)
        user, err := t.userRepo.Find(ctx, uId)
        if err != nil </span><span class="cov0" title="0">{
                if user == nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrNotFound, `user not found`, fmt.Errorf(`not found user with id : %d`, uId))
                }</span>
                <span class="cov0" title="0">return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)</span>
        }

        <span class="cov0" title="0">var (
                wg       sync.WaitGroup
                ch       = make(chan error, 2)
                taskId   = new(uint64)
                rewardId = new(uint64)
                task     = &amp;models.Task{}
        )
        wg.Add(2)

        go func() *uint64 </span><span class="cov0" title="0">{
                defer wg.Done()
                task = request.ConvertTask()
                task.UserID = user.ID
                task.Status = enums.Open
                taskId, err = t.taskRepo.Save(ctx, task)
                if err != nil </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return nil
                }</span>
                <span class="cov0" title="0">return taskId</span>
        }()

        <span class="cov0" title="0">go func() *uint64 </span><span class="cov0" title="0">{
                defer wg.Done()
                reward := request.ConvertReward()
                reward.UserID = user.ID
                rewardId, err = t.rewardRepo.Save(ctx, reward)
                if err != nil </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return nil
                }</span>
                <span class="cov0" title="0">for _, categoryId := range request.Categories.IDs </span><span class="cov0" title="0">{
                        rewardCategory := &amp;models.RewardCategory{
                                CategoryID: categoryId,
                                RewardID:   *rewardId,
                        }
                        _, err := t.rewardCategoryRepo.Save(ctx, rewardCategory)
                        if err != nil </span><span class="cov0" title="0">{
                                ch &lt;- err
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return rewardId</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(ch)
        }</span>()

        <span class="cov0" title="0">for errorCh := range ch </span><span class="cov0" title="0">{
                if errorCh != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to process task creation`, errorCh)
                }</span>
        }
        <span class="cov0" title="0">taskReward := &amp;models.TaskReward{
                TaskID:   *taskId,
                RewardID: *rewardId,
        }
        taskRewardId, err := t.taskRewardRepo.Save(ctx, taskReward)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to save reward repo`, err)
        }</span>

        <span class="cov0" title="0">result = &amp;responses.TaskResponse{
                ID:       *taskRewardId,
                TaskID:   *taskId,
                RewardID: *rewardId,
                UserID:   user.ID,
        }

        return result, nil</span>
}

func (t *taskUsecase) GetAllTasks(ctx context.Context) (results []*responses.TaskListResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        tasks, err := t.taskRepo.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get all tasks`, err)
        }</span>
        <span class="cov0" title="0">var (
                wg         sync.WaitGroup
                user       = &amp;models.User{}
                reward     = &amp;models.Reward{}
                taskReward = &amp;models.TaskReward{}
                errCh      = make(chan error, len(tasks))
        )
        for _, task := range tasks </span><span class="cov0" title="0">{
                wg.Add(1)

                go func(task *models.Task) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        user, err = t.userRepo.Find(ctx, task.UserID)
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">taskReward, err = t.taskRewardRepo.FindByTaskId(ctx, task.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">reward, err = t.rewardRepo.Find(ctx, taskReward.RewardID)
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">result := responses.NewTaskListResponse(task, user, reward)
                        results = append(results, result)</span>
                }(task)
        }

        <span class="cov0" title="0">wg.Wait()

        select </span>{
        case err = &lt;-errCh:<span class="cov0" title="0">
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get all tasks`, err)</span>
        default:<span class="cov0" title="0">
                return results, nil</span>
        }
}

func NewTaskUsecase(
        taskRepo repositories.ITaskRepository,
        rewardRepo repositories.IRewardRepository,
        rewardCategoryRepo repositories.IRewardCategoryRepository,
        taskRewardRepo repositories.ITaskRewardRepository,
        userRepo repositories.IUserRepository,
        userProfileRepo repositories.IUserProfileRepository,
        userTaskRepo repositories.IUserTaskRepository,
        uow repositories.UnitOfWork,
) *taskUsecase <span class="cov0" title="0">{
        return &amp;taskUsecase{
                taskRepo:           taskRepo,
                rewardRepo:         rewardRepo,
                rewardCategoryRepo: rewardCategoryRepo,
                taskRewardRepo:     taskRewardRepo,
                userRepo:           userRepo,
                userProfileRepo:    userProfileRepo,
                userTaskRepo:       userTaskRepo,
                uow:                uow,
        }
}</span>

var _ usecases.ITaskUsecase = &amp;taskUsecase{}
</pre>
		
		<pre class="file" id="file62" style="display: none">package usecases

import (
        "context"
        "fmt"
        "github.com/golang-jwt/jwt/v5"
        "log"
        "sync"
        "task_mission/apperror"
        "task_mission/entities/dtos/requests"
        "task_mission/entities/dtos/responses"
        "task_mission/entities/models"
        "task_mission/interfaces/repositories"
        "task_mission/interfaces/usecases"
        "task_mission/pkg/securities"
        "task_mission/utils"
        "time"
)

type userUsecase struct {
        uow             repositories.UnitOfWork
        userRepo        repositories.IUserRepository
        userProfileRepo repositories.IUserProfileRepository
        userRoleRepo    repositories.IUserRoleRepository
        userCreditRepo  repositories.IUserCreditRepository
}

func (u *userUsecase) VerifyUser(ctx context.Context, id uint64) (result *models.User, customErr *apperror.CustomError) <span class="cov0" title="0">{
        user, err := u.userRepo.Find(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrNotFound, `failed to find user`, err)
        }</span>
        <span class="cov0" title="0">user.IsVerified = true
        user, err = u.userRepo.Update(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to update user`, err)
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (u *userUsecase) RegisterUser(ctx context.Context, register *requests.UserRegisterRequest) (result *models.User, customErr *apperror.CustomError) <span class="cov0" title="0">{
        uow, err := u.uow.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed in init transaction`, err)
        }</span>
        <span class="cov0" title="0">u.uow = uow
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        u.uow.Rollback()
                        return
                }</span>
                <span class="cov0" title="0">err = u.uow.Commit()</span>
        }()

        <span class="cov0" title="0">userDoB, err := utils.StringToDate(register.DateOfBirth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrBadRequest, `date of birth is invalid format`, err)
        }</span>
        <span class="cov0" title="0">user := &amp;models.User{
                Name:        utils.UserFullName(register.FirstName, register.LastName),
                UserName:    register.UserName,
                DateOfBirth: userDoB,
                Gender:      register.Gender,
        }
        userId, err := u.userRepo.Save(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to create user`, err)
        }</span>

        <span class="cov0" title="0">var (
                wg sync.WaitGroup
                ch = make(chan error, 3)
        )
        wg.Add(3)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                password, err := utils.HashPassword(register.Password)
                if err != nil </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">userProfile := &amp;models.UserProfile{
                        Email:    register.Email,
                        Password: password,
                        UserID:   *userId,
                }
                _, err = u.userProfileRepo.Save(ctx, userProfile)
                if err != nil </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                userRole := &amp;models.UserRole{
                        UserID: *userId,
                        RoleID: 3,
                }
                _, err = u.userRoleRepo.Save(ctx, userRole)
                if err != nil </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                userCredit := &amp;models.UserCredit{
                        UserID: *userId,
                }
                _, err := u.userCreditRepo.Save(ctx, userCredit)
                if err != nil </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(ch)
        }</span>()

        <span class="cov0" title="0">for err := range ch </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to perform user operation`, err)
                }</span>
        }

        <span class="cov0" title="0">result, err = u.userRepo.Find(ctx, *userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to get user`, err)
        }</span>
        <span class="cov0" title="0">log.Println(result)

        return result, nil</span>
}

func (u *userUsecase) LoginUser(ctx context.Context, login *requests.UserLoginRequest) (result *responses.UserLoginResponse, customErr *apperror.CustomError) <span class="cov0" title="0">{
        user, err := u.userProfileRepo.FindByEmail(ctx, login.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrNotFound, `email find`, fmt.Errorf(`user is not found`))
        }</span>
        <span class="cov0" title="0">existed := utils.ComparePassword(login.Password, user.Password)
        if !existed </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrNotFound, `password find`, fmt.Errorf(`user is not found`))
        }</span>
        <span class="cov0" title="0">userRole, err := u.userRoleRepo.FindByUserID(ctx, user.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrNotFound, `user role`, fmt.Errorf(`user is not found`))
        }</span>

        <span class="cov0" title="0">claims := &amp;securities.JWTClaim{
                UserID: user.UserID,
                RoleID: userRole.RoleID,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "Applications",
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * 1)),
                },
        }

        tokenAlgo := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        token, err := tokenAlgo.SignedString(securities.JWT_KEY)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewCustomError(apperror.ErrInternalServer, `failed to generate token`, err)
        }</span>
        <span class="cov0" title="0">result = &amp;responses.UserLoginResponse{
                Token: token,
        }
        return result, nil</span>
}

func NewUserUsecase(
        uow repositories.UnitOfWork,
        userRepo repositories.IUserRepository,
        userProfileRepo repositories.IUserProfileRepository,
        userRoleRepo repositories.IUserRoleRepository,
        userCreditRepo repositories.IUserCreditRepository) *userUsecase <span class="cov0" title="0">{
        return &amp;userUsecase{
                uow:             uow,
                userRepo:        userRepo,
                userProfileRepo: userProfileRepo,
                userRoleRepo:    userRoleRepo,
                userCreditRepo:  userCreditRepo,
        }
}</span>

var _ usecases.IUserUsecase = &amp;userUsecase{}
</pre>
		
		<pre class="file" id="file63" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "task_mission/entities/models"
        "time"
)

func UserFullName(firstName, lastName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", firstName, lastName)
}</span>

func StringToDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        dateTime, err := time.Parse("2006-01-02", dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return dateTime, nil</span>
}

func HashImageFile(imageFile string) string <span class="cov0" title="0">{
        return imageFile
}</span>

func GetFieldsOfObject(object interface{}) []string <span class="cov0" title="0">{
        fields := []string{}
        typ := reflect.TypeOf(object).Elem()
        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov0" title="0">{
                field := typ.Field(i).Name
                fields = append(fields, field)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

func CreditsAverage(credits []*models.Credit) float32 <span class="cov0" title="0">{
        if len(credits) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">creditSum := float32(0)
        for _, credit := range credits </span><span class="cov0" title="0">{
                creditSum += credit.Credit
        }</span>
        <span class="cov0" title="0">return creditSum / float32(len(credits))</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package utils

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "reflect"
        "strings"
        "task_mission/queries"
)

const (
        selectQuery = `SELECT`
        insertQuery = `INSERT`
        updateQuery = `UPDATE`
        deleteQuery = `DELETE`
)

func Save[T any](ctx context.Context, db *sql.DB, query queries.GoQuery, requests ...any) (*uint64, error) <span class="cov0" title="0">{
        err := QueryValidation(query, insertQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var id = new(uint64)
        err = db.QueryRowContext(ctx, query.ToString(), requests...).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func FindAll[T any](ctx context.Context, db *sql.DB, query queries.GoQuery) (result []*T, err error) <span class="cov0" title="0">{
        requests := new(T)
        err = QueryValidation(query, selectQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, query.ToString())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">typ := reflect.TypeOf(requests).Elem()
        var ptrs = make([]interface{}, typ.NumField())
        for i := range ptrs </span><span class="cov0" title="0">{
                ptrs[i] = reflect.New(typ.Field(i).Type).Interface()
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                request := reflect.New(typ).Elem()
                err := rows.Scan(ptrs...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for i, ptr := range ptrs </span><span class="cov0" title="0">{
                        field := request.Field(i)
                        field.Set(reflect.ValueOf(ptr).Elem())
                }</span>
                <span class="cov0" title="0">result = append(result, request.Addr().Interface().(*T))</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func Delete[T any](ctx context.Context, db *sql.DB, query queries.GoQuery, id uint64) (err error) <span class="cov0" title="0">{
        err = QueryValidation(query, deleteQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = db.ExecContext(ctx, query.ToString(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func FindByID[T any](ctx context.Context, db *sql.DB, query queries.GoQuery, id uint64, result *T) error <span class="cov0" title="0">{
        log.Println(strings.ReplaceAll(query.ToString(), "$1", fmt.Sprintf("%d", id)))

        err := QueryValidation(query, selectQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stmt, err := db.PrepareContext(ctx, query.ToString())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        var ptrs []interface{}

        typ := reflect.TypeOf(result).Elem()

        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov0" title="0">{
                field := reflect.ValueOf(result).Elem().Field(i)
                ptrs = append(ptrs, field.Addr().Interface())
        }</span>

        <span class="cov0" title="0">err = stmt.QueryRowContext(ctx, id).Scan(ptrs...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func Update[T any](ctx context.Context, db *sql.DB, query queries.GoQuery, requests ...any) (err error) <span class="cov0" title="0">{
        err = QueryValidation(query, updateQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = db.ExecContext(ctx, query.ToString(), requests...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "github.com/iancoleman/strcase"
        "log"
        "net/http"
        "reflect"
        "task_mission/apperror"
        "task_mission/entities/dtos/responses"
)

func ContentType(w http.ResponseWriter, contentType string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", contentType)
}</span>

func BindJSON(req *http.Request, request interface{}) error <span class="cov0" title="0">{
        return json.NewDecoder(req.Body).Decode(&amp;request)
}</span>

func BindForm(req *http.Request, request any) error <span class="cov0" title="0">{
        err := req.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bindForm := make(map[string]interface{})
        for key, values := range req.Form </span><span class="cov0" title="0">{
                log.Printf("key : %s value : %s", key, values[0])
                bindForm[key] = values[0]
        }</span>

        <span class="cov0" title="0">fields := GetFieldsOfObject(request)

        for _, field := range fields </span><span class="cov0" title="0">{
                val := reflect.ValueOf(bindForm[strcase.ToSnake(field)])
                if val.IsValid() </span><span class="cov0" title="0">{
                        fieldValue := reflect.ValueOf(request).Elem().FieldByName(field)
                        if fieldValue.IsValid() &amp;&amp; fieldValue.CanSet() </span><span class="cov0" title="0">{
                                if val.Type().AssignableTo(fieldValue.Type()) </span><span class="cov0" title="0">{
                                        fieldValue.Set(val)
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Errorf("type conversion error for field %s", field)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func ResponseHandler(w http.ResponseWriter, responseCode int, message string, dataKey *string, responseData any, err error) <span class="cov0" title="0">{
        w.WriteHeader(responseCode)
        responseMap := make(map[string]any)
        if dataKey != nil &amp;&amp; responseData != nil </span><span class="cov0" title="0">{
                responseMap[*dataKey] = responseData
        }</span>
        <span class="cov0" title="0">response := responses.NewResponse(message, responseMap, err)
        log.Print(response)
        err = json.NewEncoder(w).Encode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>
}

func ErrorHandler(w http.ResponseWriter, customErr *apperror.CustomError) <span class="cov0" title="0">{
        w.WriteHeader(customErr.ErrCode())
        response := responses.NewResponse("", nil, customErr)
        json.NewEncoder(w).Encode(&amp;response)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package utils

import (
        "fmt"
        "golang.org/x/crypto/bcrypt"
        "path"
        "strings"
        "task_mission/queries"
)

func QueryValidation(query queries.GoQuery, command string) error <span class="cov0" title="0">{
        queryStr := query.ToString()
        if !strings.Contains(queryStr, command) </span><span class="cov0" title="0">{
                return fmt.Errorf(`the query command is not valid`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(hash), err
}</span>

func ComparePassword(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func ValidateFileType(fileName string) bool <span class="cov0" title="0">{
        extension := path.Ext(fileName)
        imageFileExts := []string{
                "jpg",
                "jpeg",
                "png",
        }
 
        flag := false

        for _, imageFileExt := range imageFileExts </span><span class="cov0" title="0">{
                if extension == imageFileExt </span><span class="cov0" title="0">{
                        flag = true
                }</span>
        }

        <span class="cov0" title="0">if flag == true </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
